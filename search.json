[{"title":"CSO LUA 創立教學","path":"/GFBlog//blog/20240507/CSO-LUA-創立教學/","content":"步驟 選擇要套用地圖，只能在一人房使用。 進入遊戲後，按下 V + 8。 選擇新創立並輸入你的資料夾名稱，在點擊確認。 視窗化的情況下，會自動在電腦上打開資料夾位置。 程式碼撰寫完成，按下讀取，讀取檔案。 按下測試開始即可。 已經得知檔案路徑，並且撰寫完程式碼，可直接從第5點開始。 Script報錯程式碼有撰寫錯誤，詳情請查看遊戲內控制台，按下~即可。","tags":["CSO LUA","CSO LUA小技巧"],"categories":["CSO LUA"]},{"title":"CSO LUA 相關內建函式說明","path":"/GFBlog//blog/20240504/CSO-LUA-相關內建函式說明/","content":"目錄 關鍵字 數學運算子 字串相接運算子 邏輯運算子 關係運算子 bitwise 位元運算子 Lua Functions 關鍵字1234and break do else elseifend false for function ifin local nil not orrepeat return then true until while 數學運算子1+ - * / % ^ 1234561 + 7 -- 輸出: 82 - 8 -- 輸出: -63 * 9 -- 輸出: 274 / 10 -- 輸出: 0.45 % 11 -- 輸出: 56 ^ 12 -- 輸出: 2176782336 字串相接運算子1.. 1str = &quot;Hello&quot; .. &quot;World&quot; -- str = Hello World 邏輯運算子123and -- 且or -- 或not -- 相反 123456 true and true -- 輸出: true true and false -- 輸出: false true or true -- 輸出: true true or false -- 輸出: truefalse or false -- 輸出: falsenot true -- 輸出: false 關係運算子12345678== -- 相等~= -- 不相等&gt; -- 大於&lt; -- 小於&gt;= -- 大於等於&lt;= -- 小於等於 12345678111 == 111 -- 輸出: true222 ~= 222 -- 輸出: false300 &gt; 400 -- 輸出: false300 &lt; 400 -- 輸出: true400 &gt;= 400 -- 輸出: true400 &gt;= 401 -- 輸出: false400 &lt;= 400 -- 輸出: true400 &lt;= 399 -- 輸出: false bitwise 位元運算子1&amp; | ~ &lt;&lt; &gt;&gt; AND 12345673 &amp; 5 -- 輸出: 1算法: 00000011 &amp; 00000101------------- 00000001 OR 12345673 | 5 -- 輸出: 7算法: 00000011 | 00000101------------- 00000111 XOR 12345673 ~ 5 -- 輸出: 6算法: 00000011 ~ 00000101------------- 00000110 Right Shift 123457 &gt;&gt; 1 -- 輸出: 3算法:0000 0111 -- 原本0000 0011 -- 結果 Left Shift 123457 &lt;&lt; 1 -- 輸出: 14算法:0000 0111 -- 原本0000 1110 -- 結果 NOT 123~7 -- 輸出: -8~10 -- 輸出: -11~999 -- 輸出: -1000 Lua Functionstonumber： 轉 整數 資料型態 12345tonumber(&quot;12as&quot;) -- niltonumber(&quot;12&quot;) -- 12tonumber(123.3) -- 123.3tonumber(1230.0) -- 1230tonumber(1230) -- 1230 tostring： 轉 字串 資料型態 123tostring(&quot;fafsaf!$&quot;) -- &quot;fafsaf!$&quot;tostring(5606) -- &quot;5606&quot;tostring(125.15665) -- &quot;125.15665&quot; type： 識別 資料型態 12345678a, b, c, d, e, f, g = 1, 2.3, &quot;4&quot;, true, nil, &#123;&#125;, function() endtype(a) -- numbertype(b) -- numbertype(c) -- stringtype(d) -- booleantype(e) -- niltype(f) -- tabletype(g) -- function assert： 檢查 異常錯誤，會導致Script錯誤 123a, b, c, d, e, f, g = 1, 2.3, &quot;4&quot;, true, nil, &#123;&#125;, function() enda = 1; assert(a == 1) -- 自訂的錯誤訊息，不一定要a = 2; assert(a == 1, &quot;變數a只能是1&quot;) -- Script錯誤，控制台會拋出你自訂的錯誤訊息。 error： 異常錯誤訊息，會導致Script錯誤 1234pos = &#123;x = 1, y = 1, z = 1&#125;if pos.x == 1 then\terror(&quot;座標X錯誤&quot;)end setmetatable： 元表，這有點難，可以做成類似class 1setmetatable() 詳情 https://www.runoob.com/lua/lua-metatables.html getmetatable： 返回對像元表 1getmetatable() 詳情 https://www.runoob.com/lua/lua-metatables.html print： 打印任何資料在控制台 1print() log： 在遊戲路徑&#x2F;bin&#x2F;script.log 打印任何資料 1log()","tags":["CSO LUA","CSO LUA小技巧"],"categories":["CSO LUA"]},{"title":"CSO LUA 學習資源","path":"/GFBlog//blog/20240504/CSO-LUA-學習資源/","content":"CSO LUA API文檔 台灣網站 英文網站 韓國網站 LUA 學習網站 Lua 教程|菜鳥教程 個人作品崩潰金魚燒 【DeathRun】死亡奔跑 (遊戲內地圖複製獲取) 【LUA自取】 地速顯示 (遊戲內地圖複製獲取) 【心得】額外的怪物代碼取得方式 (巴哈姆特) CSO LUA Speedometer (Youtube、Github) CSO LUA Chat (Youtube、Github) CSO LUA PlayerDirection (Youtube、Github) CSO 武器網站 (連結、Github) AnggaraNothing(印尼大神) cso-lua-scripting-master (Github) Donxon SDK (Document、Github) misk(Ain神的規律P) 【攻略】不會寫程式也能擁有Lua指令! (遊戲內地圖複製獲取、巴哈姆特) 【攻略】CSO lua零基礎小教室（一）接觸lua (巴哈姆特) 【攻略】CSO lua零基礎小教室（二）函式 (巴哈姆特) 【攻略】CSO lua零基礎小教室（三）資料型態與表 (巴哈姆特) 【攻略】CSO lua零基礎小教室（四）淺談API (巴哈姆特) 【攻略】CSO lua零基礎小教室（五）UI圖型與文字顯示 (巴哈姆特) 【攻略】CSO lua零基礎小教室（六）製作五彩繽紛的怪物 (巴哈姆特) 【攻略】Studio模式 [Lua]CSO API 總教學 (巴哈姆特) 【攻略】Studio模式 [Lua]CSO API 進階應用 (請用電腦觀看) (巴哈姆特) 【攻略】可以對話的殭屍NPC (巴哈姆特) 【心得】【LUA小成果】製作 LUA重生殭屍，殭屍群類別 (巴哈姆特) 【心得】LUA在螢幕上顯示 【圓】 (巴哈姆特) 【心得】自製 Lua class : UI.Content 分享 (請使用電腦觀看) (巴哈姆特) TheM00N(익스트림버니합) kz amxmodx Lua Script (遊戲內地圖複製獲取) yutinglia 【心得】[ Lua ]像素圖顯示 (巴哈姆特) ruby2009g 【心得】LUA在螢幕上顯示 【直角梯形】 (巴哈姆特) 【心得】[lua]以按鍵方式如何只執行1次 (巴哈姆特) 【密技】[LUA]進場15秒內會一直自殺 (巴哈姆特) 【密技】LUA-雷達改良版(如果有人再次改良可以在留言給大家使用) (巴哈姆特) LukeTseng1 【心得】【Lua介面UI純享】本人製作的災厄之章UI介面 可供大眾使用 (巴哈姆特) 冷凍魚(Yuugure) （Yuugure）區域互動 LUA (遊戲內地圖複製獲取、巴哈姆特) （Yuugure）Boss血條 LUA (遊戲內地圖複製獲取、巴哈姆特) 火龍、柚子 NPC對話框功能演示 (遊戲內地圖複製獲取)","tags":["CSO LUA","CSO LUA小技巧"],"categories":["CSO LUA"]},{"title":"CSO LUA 檔案建置與配置","path":"/GFBlog//blog/20240504/CSO-LUA-檔案建置與配置/","content":"🛠️建置建議使用視窗化建立。 初次使用 LUA，應從遊戲內進行創建，因為檔案位置可能會變動，導致無法找到檔案。 如果在讀取檔案時找不到檔案，可能是因為官方已更改儲存位置。此時，只需按下「新建立」按鈕即可。 建立方法有兩種： 在遊戲內按下「新建立」按鈕。 如果已知道檔案儲存路徑，可以直接在相應資料夾內建立。 📑配置在讀取檔案時，只能讀取 project.json 檔案。 讀取的方式如下:當遊戲房間初次連線時，會執行一次 game.lua 檔案。之後每位玩家連線後，都會執行 ui.lua 檔案。房間內有幾個玩家就會讀取幾次 ui.lua 檔案。 預設情況下，配置如下所示 12345678&#123; &quot;game&quot;:[ &quot;game.lua&quot; ], &quot;ui&quot;:[ &quot;ui.lua&quot; ]&#125; 讀取檔案的順序檔案會按照配置中的順序進行讀取。在 game 部分，會先讀取 common.lua 檔案，再讀取 game.lua；而在 ui 部分，則會先讀取 common.lua 檔案，再讀取 ui.lua。 後面讀取的檔案中，前面的檔案所定義的變數是可以被後面的檔案所使用的。 若使用 local 變數，則只能在當前檔案中使用，無法跨檔案使用。 12345678910&#123; &quot;game&quot;:[ &quot;common.lua&quot;, &quot;game.lua&quot; ], &quot;ui&quot;:[ &quot;common.lua&quot;, &quot;ui.lua&quot; ]&#125; 使用Common功能若需要使用 Common 功能，需另外新增一個檔案，命名為 common.lua，然後在 project.json 檔案中進行配置。 只需建立一個 common.lua 檔案即可使用 Common 功能，但前提是要在 game 和 ui 中同時讀取。 common.lua 的名稱可以自訂，不一定要命名為 common.lua。 12345678910&#123; &quot;game&quot;:[ &quot;common.lua&quot;, &quot;game.lua&quot; ], &quot;ui&quot;:[ &quot;common.lua&quot;, &quot;ui.lua&quot; ]&#125; 不理想的寫法 下方想要使用Common的功能，但讀取的檔案卻不一樣，這樣的話common.lua和data.lua，都需要寫出相同的Common功能，才能使用。 取同名稱的檔案可以節省檔案並方便管理。 12345678910&#123; &quot;game&quot;:[ &quot;data.lua&quot;, &quot;game.lua&quot; ], &quot;ui&quot;:[ &quot;common.lua&quot;, &quot;ui.lua&quot; ]&#125;","tags":["CSO LUA","CSO LUA小技巧"],"categories":["CSO LUA"]},{"title":"CSO LUA 自訂義UI物件","path":"/GFBlog//blog/20240504/CSO-LUA-自訂義UI物件/","content":"當你想要在CSO LUA中建立更多元的UI物件時，官方僅提供了UI.Box和UI.Text兩個選項。但是，如果你希望有更多自定義的UI物件，你可以透過手刻Class物件來實現。這樣一來，你就能夠根據自己的需求來客製化UI物件了！ Lua 中的物件導向Lua 是一種輕量級的語言，沒有內建的 class 概念，但可以通過其他方式模擬類似的行為，例如使用表（table）和元表（metatable）來實現對象導向的編程。如果對此不太熟悉，可以參考一些線上資源，比如這個網站。 文字陰影 UI 物件假設我們要創建一個自定義的文字陰影 UI 物件。首先，讓我們看一下如果不使用 class 的話，程式碼會是怎麼樣的： 12345678910111213141516171819TextShadow = UI.Text.Create()TextShadow:Set(&#123; text = &quot;哈囉&quot;, font = &quot;small&quot;, align = &quot;left&quot;, x = 2, --&lt;&lt; 偏移2點 y = 2, --&lt;&lt; 偏移2點 width = 100, height = 30, r = 255, g = 255, b = 255&#125;)Text = UI.Text.Create()Text:Set(&#123; text = &quot;哈囉&quot;, font = &quot;small&quot;, align = &quot;left&quot;, x = 0, y = 0, width = 100, height = 30, r = 255, g = 255, b = 255&#125;) 這樣的程式碼看起來相當冗長且不易維護。現在，讓我們看看如何使用 class 來實現同樣的功能。 定義 TextShadow Class TextShadow = &#123;&#125;：這一行創建了一個名為 TextShadow 的空表，用於存儲自定義物件的方法和屬性。 function TextShadow:Create()：這一行定義了一個叫做 Create 的方法，該方法用於創建新的 TextShadow 物件。使用 : 語法定義的方法隱式地將物件自身作為第一個參數（類似於其他語言中的 this 或 self）。 在 Create 方法中： 首先，創建了一個名為 newObject 的新表，用於存儲 TextShadow 物件的屬性和方法。 在 newObject 表中，設置了一個叫做 SetArg 的表，其中包含了一系列的屬性，用於設置陰影效果的參數。這些參數包括了文本內容 (text)、字體 (font)、對齊方式 (align)，，位置(x 和 y)，大小 (width 和 height)，顏色 (r、g、b 和 a) 以及偏移量 (offset)。 接著，創建了一個 UI 表，其中包含了兩個名為 back 和 front 的屬性，這些屬性分別表示陰影的背景和前景，並且使用了 UI.Text.Create() 方法來創建相應的文本 UI 物件。 最後，設置了一個名為 visible 的屬性，表示該陰影是否可見，並將其設置為預設值 true。 總的來說，這段程式碼創建了一個具有自定義屬性和方法的 TextShadow 物件，用於表示文本的陰影效果。通過這種方式，可以方便地創建。 來自 ChatGPT 說明 1234567891011121314151617181920212223242526-- 定義物件TextShadow = &#123;&#125;function TextShadow:Create() -- 自訂義物件內容並給預設值，內容怎樣都行。 local newObject = &#123; SetArg = &#123; text = &quot;&quot;, font = &quot;small&quot;, align = &quot;left&quot;, x = 0, y = 0, width = 0, height = 0, r = 255, g = 255, b = 255, a = 255, offset = 2 &#125;, UI = &#123; back = UI.Text.Create(), front = UI.Text.Create() &#125;, visible = true &#125; return setmetatable(newObject, &#123;__index = TextShadow&#125;)end 上述程式碼定義了一個 TextShadow Class，其中包含了一個 Create 方法用於創建新的 TextShadow 物件。該物件包含了一個 SetArg 表，用於存儲設定參數，一個 UI 表用於存儲 UI 元件，以及一個 visible 屬性用於表示陰影是否可見。 更新 UI接下來我們在定義一個Update函式，來更新我們的UI要怎麼設定。 function TextShadow:Update()：這一行定義了一個叫做 Update 的方法，該方法用於更新 TextShadow 物件的 UI。 local arg = self.SetArg：這一行將 self.SetArg 表示的陰影設置參數儲存在本地變數 arg 中，以便於後續使用。 local setting = &#123;...&#125;：這一行創建了一個名為 setting 的表，其中包含了陰影效果的設定。對於每個 UI 元素（back 和 front），設置了相應的位置（x 和 y）、顏色（r、g、b 和 a）等參數。 for k,v in pairs(self.UI) do：這一行使用 pairs 函數遍歷 self.UI 表中的所有元素，其中 k 是鍵（back 或 front），而 v 則是相應的值（UI.Text 物件）。 在迴圈中，創建了一個名為 temp 的表，用於存儲更新後的 UI 參數。這些參數包括了位置 (x 和 y)，大小 (width 和 height)，顏色 (r、g、b 和 a)，以及文本相關的屬性（text、font、align）。 v:Set(temp)：這一行調用了 UI.Text 物件的 Set 方法，並將更新後的參數 temp 傳遞給該方法，從而更新了 UI 的屬性。 總的來說，這段程式碼是用來更新 TextShadow 物件的 UI，並根據設置的參數來更新相應的屬性，例如位置、大小、顏色等。這樣一來，可以在程式執行過程中動態地改變陰影效果的外觀。 來自 ChatGPT 說明 123456789101112131415161718192021222324252627-- 更新UIfunction TextShadow:Update() local arg = self.SetArg local setting = &#123; back = &#123;x = arg.offset, y = arg.offset, r = 0, g = 0, b = 0, a = arg.a&#125;, front = &#123;x = 0, y = 0, r = arg.r, g = arg.g, b = arg.b, a = arg.a&#125; &#125; for k,v in pairs(self.UI) do local temp = &#123; text = arg.text, font = arg.font, align = arg.align, x = arg.x + setting[k].x, y = arg.y + setting[k].y, width = arg.width, height = arg.height, r = setting[k].r, g = setting[k].g, b = setting[k].b, a = setting[k].a &#125; v:Set(temp) endend 上述程式碼定義了一個 Update 方法，用於更新 TextShadow 物件的 UI。該方法根據設定參數更新 UI 的各個屬性，包括位置、大小、顏色等。 其他必需的函式 function TextShadow:Set(args)：這一行定義了一個名為 Set 的方法，該方法用於設置陰影效果的屬性。首先，它檢查傳入的參數是否為一個表，如果是的話，則調用 setArgs 函數將該表中的值設置到 self.SetArg 中。最後，它調用了 self:Update() 方法來更新 UI。 function TextShadow:Get()：這一行定義了一個名為 Get 的方法，該方法用於取得陰影效果目前的設置值。它調用了 clone 函數來複製 self.SetArg 表，以防止直接返回引用。 function TextShadow:Show()：這一行定義了一個名為 Show 的方法，該方法用於顯示陰影效果的 UI。它調用了 deepCall 函數來遞迴地調用 UI 表中每個元素的 Show 方法，以顯示相應的 UI。最後，將 self.visible 設置為 true，表示陰影效果已經顯示。 function TextShadow:Hide()：這一行定義了一個名為 Hide 的方法，該方法用於隱藏陰影效果的 UI。它同樣調用了 deepCall 函數來遞迴地調用 UI 表中每個元素的 Hide 方法，以隱藏相應的 UI。最後，將 self.visible 設置為 false，表示陰影效果已經隱藏。 function TextShadow:IsVisible()：這一行定義了一個名為 IsVisible 的方法，該方法用於返回陰影效果是否可見的狀態。它簡單地返回 self.visible 的值，以表示陰影效果目前是否處於顯示狀態。 總的來說，這些方法為 TextShadow 物件提供了設置、取得、顯示和隱藏陰影效果的功能，並提供了一個方法來查詢陰影效果目前是否可見。 來自 ChatGPT 說明 1234567891011121314151617181920212223242526272829-- 設置function TextShadow:Set(args) if type(args) == &quot;table&quot; then setArgs(self.SetArg, args) end self:Update()end-- 取得設定值function TextShadow:Get() return clone(self.SetArg)end-- 顯示function TextShadow:Show() deepCall(self.UI, &quot;Show&quot;) self.visible = trueend-- 隱藏function TextShadow:Hide() deepCall(self.UI, &quot;Hide&quot;) self.visible = falseend-- 返回顯示狀態function TextShadow:IsVisible() return self.visibleend 上述程式碼定義了一些必需的函式，包括設置、取得設定值、顯示、隱藏和返回顯示狀態等功能。這些函式使得 TextShadow 物件更加易用和靈活。 輔助函式 local function setArgs(data, args)：這是一個局部函數，用於更新表中的值。它接受兩個參數，data 表示待更新的表，args 表示包含新值的表。該函數通過遍歷 data 表中的每個鍵，檢查是否存在相應的 args 表中的值，如果是的話，則將 data 表中的值更新為 args 表中的對應值。如果鍵對應的值是一個表，則遞迴調用 setArgs 函數以處理嵌套的表。 local function deepCall(table, funcName, args)：這是一個局部函數，用於在表中深層遞迴地調用指定的函式。它接受三個參數，table 表示待遍歷的表，funcName 表示要調用的函式名稱，args 表示要傳遞給該函式的參數。該函數遍歷 table 表中的每個元素，如果元素是一個表，則遞迴調用 deepCall 函數以處理嵌套的表；如果元素是一個 userdata，則調用該 userdata 對象的指定函式，並傳遞參數 args。 local function clone(table)：這是一個局部函數，用於深層複製表。它接受一個表作為參數，並返回該表的深層複製。該函數遍歷原始表中的每個鍵值對，如果值是一個表，則遞迴調用自身以處理嵌套的表；否則，將鍵值對直接複製到新的表中。 這些輔助函數提供了對表的操作，使得程式碼更加模組化和易於理解。通過這些函數，可以更方便地處理複雜的數據結構和執行深層遞迴操作。 來自 ChatGPT 說明 123456789101112131415161718192021222324252627282930313233343536-- 更新設定值local function setArgs(data, args) for k in pairs(data) do if type(data[k]) == type(args[k]) then if type(data[k]) == &quot;table&quot; then setArgs(data[k], args[k]) else data[k] = args[k] end end endend-- 深層調用，調用指定函式local function deepCall(table, funcName, args) for _,v in pairs(table) do if type(v) == &quot;table&quot; then deepCall(v, funcName, args) elseif type(v) == &quot;userdata&quot; then v[funcName](v, args) end endend-- 複製表(table)local function clone(table) local temp = &#123;&#125; for k,v in pairs(table) do if type(v) == &quot;table&quot; then temp[k] = clone(v) else temp[k] = v end end return tempend 上述程式碼定義了三個輔助函式，分別是更新設定值的 setArgs、深層調用的 deepCall 和複製表的 clone。這些函式用於處理表的操作，使得程式碼更加模組化和易於理解。 完整代碼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140-- 更新設定值local function setArgs(data, args) for k in pairs(data) do if type(data[k]) == type(args[k]) then if type(data[k]) == &quot;table&quot; then setArgs(data[k], args[k]) else data[k] = args[k] end end endend-- 深層調用，調用指定函式local function deepCall(table, funcName, args) for _,v in pairs(table) do if type(v) == &quot;table&quot; then deepCall(v, funcName, args) elseif type(v) == &quot;userdata&quot; then v[funcName](v, args) end endend-- 複製表(table)local function clone(table) local temp = &#123;&#125; for k,v in pairs(table) do if type(v) == &quot;table&quot; then temp[k] = clone(v) else temp[k] = v end end return tempend-- 定義物件TextShadow = &#123;&#125;function TextShadow:Create() -- 自訂義物件內容並給預設值，內容怎樣都行。 local newObject = &#123; SetArg = &#123; text = &quot;&quot;, font = &quot;small&quot;, align = &quot;left&quot;, x = 0, y = 0, width = 0, height = 0, r = 255, g = 255, b = 255, a = 255, offset = 2 &#125;, UI = &#123; back = UI.Text.Create(), front = UI.Text.Create() &#125;, visible = true &#125; return setmetatable(newObject, &#123;__index = TextShadow&#125;)end-- 更新UIfunction TextShadow:Update() local arg = self.SetArg local setting = &#123; back = &#123;x = arg.offset, y = arg.offset, r = 0, g = 0, b = 0, a = arg.a&#125;, front = &#123;x = 0, y = 0, r = arg.r, g = arg.g, b = arg.b, a = arg.a&#125; &#125; for k,v in pairs(self.UI) do local temp = &#123; text = arg.text, font = arg.font, align = arg.align, x = arg.x + setting[k].x, y = arg.y + setting[k].y, width = arg.width, height = arg.height, r = setting[k].r, g = setting[k].g, b = setting[k].b, a = setting[k].a &#125; v:Set(temp) endend-- 設置function TextShadow:Set(args) if type(args) == &quot;table&quot; then setArgs(self.SetArg, args) end self:Update()end-- 取得設定值function TextShadow:Get() return clone(self.SetArg)end-- 顯示function TextShadow:Show() deepCall(self.UI, &quot;Show&quot;) self.visible = trueend-- 隱藏function TextShadow:Hide() deepCall(self.UI, &quot;Hide&quot;) self.visible = falseend-- 返回顯示狀態function TextShadow:IsVisible() return self.visibleend-- 測試local screen = UI.ScreenSize()local center = &#123;x = screen.width / 2, y = screen.height / 2&#125;text = TextShadow:Create()text:Set(&#123; text = &quot;哈囉 你好~&quot;, font = &quot;medium&quot;, align = &quot;center&quot;, x = 0, y = center.y, width = screen.width, height = 50, r = 0, g = 128, b = 255, offset = 5&#125;) 上述是完整的程式碼範例，展示了如何使用 Class 物件來建立自定義的文字陰影 UI 物件。這樣的設計使得程式碼更加模組化和易於理解，同時也提供了更好的可擴展性和重用性。","tags":["CSO LUA","CSO LUA小技巧"],"categories":["CSO LUA"]},{"title":"CSO LUA 小技巧","path":"/GFBlog//blog/20240504/CSO-LUA-小技巧/","content":"玩家座標的使用這可能是你的寫法，看起來沒毛病，但這會讓程式碼很攏長。 123456789x = &#123;&#125;y = &#123;&#125;z = &#123;&#125;function Game.Rule:OnPlayerConnect(player) x[player.index] = player.position.x y[player.index] = player.position.y z[player.index] = player.position.zend 這是比較理想的寫法，一個變數直接儲存XYZ。 12345playerPosition = &#123;&#125;function Game.Rule:OnPlayerConnect(player) playerPosition[player.index] = player.positionend 舉個例子，像是KZ的存讀點功能。 123456789101112playerPosition = &#123;&#125;function Game.Rule:OnPlayerSignal(player, signal) if signal == 1 then -- 當玩家按下1，儲存座標 playerPosition[player.index] = player.position elseif signal == 2 then -- 當玩家按下2，讀取座標 player.position = playerPosition[player.index] endend 大量且重複性高的EntityBlock創建這我很常用在KZ裡面的跳板，10個關卡，每一關可能有10個板子，那就要創建100個座標和函式。 123456789101112131415161718playerPosition = &#123;&#125;block_1 = Game.EntityBlock.Create(&#123;x = 1, y = 1, z = 1&#125;)function block_1:OnTouch(player) playerPosition[player.index] = player.positionendblock_2 = Game.EntityBlock.Create(&#123;x = 2, y = 2, z = 2&#125;)function block_2:OnTouch(player) playerPosition[player.index] = player.positionendblock_3 = Game.EntityBlock.Create(&#123;x = 3, y = 3, z = 3&#125;)function block_3:OnTouch(player) playerPosition[player.index] = player.positionend...無限循環 只要把座標全部都彙整進一個變數，利用迴圈來跑就不用再寫無意義的函式。 123456789101112blocks = &#123; &#123;x = 1, y = 1, z = 1&#125;, &#123;x = 2, y = 2, z = 2&#125;, &#123;x = 3, y = 3, z = 3&#125;&#125;for k,v in pairs(blocks) do local block = Game.EntityBlock.Create(v) function block:OnTouch(player) playerPosition[player.index] = player.position endend 動態玩家排名系統直接利用Lua內建函式table.sort幫我們處立即可。 123-- list: 欲排序的表(table)-- comp: 自定義排序方式(function)table.sort(list [, comp]) 1234567891011121314151617181920playerRank = &#123; &#123;player = player, time = 15&#125;, -- 玩家一 &#123;player = player, time = 17&#125;, -- 玩家二 &#123;player = player, time = 30&#125;, -- 玩家三 &#123;player = player, time = 10&#125;, -- 玩家四 &#123;player = player, time = 13&#125;, -- 玩家五&#125;-- comp: 自訂義排序，將表裡面的time屬性進行比較，時間快的排越前面。function sort(a, b) return a.time &lt; b.timeend-- 執行排序功能table.sort(playerRank, sort)--[[結果: playerRank = &#123;玩家四, 玩家五, 玩家一, 玩家二, 玩家三&#125;]] 多個玩家的SyncValue優化想要把Game多個玩家的資料傳送到UI，你可能會這麼做。這也沒毛病，但如果寫到24人，實在是太攏長了。 12345678910111213141516-- game.luaInitialLevel = 1sync_PlayerLevel_1 = Game.SyncValue.Create(&quot;sync_PlayerLevel.1&quot;)sync_PlayerLevel_2 = Game.SyncValue.Create(&quot;sync_PlayerLevel.2&quot;)sync_PlayerLevel_3 = Game.SyncValue.Create(&quot;sync_PlayerLevel.3&quot;)function Game.Rule:OnPlayerConnect(player) if player.index == 1 then sync_PlayerLevel_1.value = InitialLevel elseif player.index == 2 then sync_PlayerLevel_2.value = InitialLevel elseif player.index == 3 then sync_PlayerLevel_3.value = InitialLevel endend 12345678910111213-- ui.luasync_PlayerLevel_1 = UI.SyncValue.Create(&quot;sync_PlayerLevel.1&quot;)function sync_PlayerLevel_1:OnSync() -- do something endsync_PlayerLevel_2 = UI.SyncValue.Create(&quot;sync_PlayerLevel.2&quot;)function sync_PlayerLevel_2:OnSync() -- do something endsync_PlayerLevel_3 = UI.SyncValue.Create(&quot;sync_PlayerLevel.3&quot;)function sync_PlayerLevel_3:OnSync() -- do something end 只要改成這樣，程式碼就會變得簡潔、易懂。 1234567891011-- game.luaInitialLevel = 1sync_PlayerLevel = &#123;&#125;for i = 1, 24 do sync_PlayerLevel[i] = Game.SyncValue.Create(&quot;sync_PlayerLevel.&quot; .. i)endfunction Game.Rule:OnPlayerConnect(player) sync_PlayerLevel[player.index].value = InitialLevelend 12345-- ui.luasync_PlayerLevel = UI.SyncValue.Create(&quot;sync_PlayerLevel.&quot; .. UI.PlayerIndex())function sync_PlayerLevel:OnSync() -- do something end 數字轉貨幣格式 來源 123456789function comma_value(n) local left,num,right = string.match(n,&#x27;^([^%d]*%d)(%d*)(.-)$&#x27;) return left..(num:reverse():gsub(&#x27;(%d%d%d)&#x27;,&#x27;%1,&#x27;):reverse())..rightendprint(comma_value(10000000)) -- 10,000,000print(comma_value(&quot;10000000&quot;)) -- 10,000,000print(comma_value(123456789)) -- 123,456,789print(comma_value(1234567890)) -- 1,234,567,890 秒數轉換時間格式這個可以轉換成: 小時:分鐘:秒 00:00:00 1234567891011function SecondsToTime(sec) local hour = math.floor(sec / 3600) local minute = math.floor(sec / 60) - (hour * 60) local seconds = math.floor(sec % 60) return string.format(&quot;%02d:%02d:%02d&quot;, hour, minute, seconds)endprint(SecondsToTime(0)) -- 00:00:00print(SecondsToTime(100)) -- 00:01:40print(SecondsToTime(1280)) -- 00:21:20print(SecondsToTime(3600)) -- 01:00:00 這個可以轉換成: 分鐘:秒.毫秒 00:00.00 12345678910function SecondsToTime(sec) local minute = math.floor(sec / 60) local seconds = math.floor(sec % 60) return string.format(&quot;%02d:%05.2f&quot;, minute, seconds)endprint(SecondsToTime(0.661)) -- 00:00:00.66print(SecondsToTime(100.185)) -- 00:01:40.19print(SecondsToTime(1280.1698)) -- 00:21:20.17print(SecondsToTime(3600.9541)) -- 01:00:00.95 UI漸層顏色1234-- colorA: (table)A顏色 &#123;r = 255, g = 255, b = 255, a = 255&#125;-- colorB: (table)B顏色 &#123;r = 255, g = 0, b = 255, a = 255&#125;-- boxCount: (number)產生A~B之間的漸變顏色數量GetGradient(colorA, colorB, boxCount) 1234567891011121314151617181920212223function GetGradient(colorA, colorB, boxCount) colorA.a = colorA.a or 255 colorB.a = colorB.a or 255 local temp = &#123;&#125; for i = 1, boxCount do local rAvg = colorA.r + math.floor((colorB.r - colorA.r) * i / boxCount) local gAvg = colorA.g + math.floor((colorB.g - colorA.g) * i / boxCount) local bAvg = colorA.b + math.floor((colorB.b - colorA.b) * i / boxCount) local aAvg = colorA.a + math.floor((colorB.a - colorA.a) * i / boxCount) table.insert(temp, &#123;r = rAvg, g = gAvg, b = bAvg, a = aAvg&#125;) end return tempendprint(GetGradient(&#123;r=255,g=255,b=255&#125;, &#123;r=255,g=0,b=255&#125;, 6))--[[output &#123; &#123;r=255,g=212,b=255&#125;,&#123;r=255,g=170,b=255&#125;,&#123;r=255,g=127,b=255&#125;, &#123;r=255,g= 85,b=255&#125;,&#123;r=255,g= 42,b=255&#125;,&#123;r=255,g= 0,b=255&#125; &#125;]]","tags":["CSO LUA","CSO LUA小技巧"],"categories":["CSO LUA"]},{"title":"about","path":"/GFBlog/about/index.html","content":"123"},{"title":"API 更新日誌","path":"/GFBlog/wiki/csolua/changes.html","content":"1.5 - 2019-11-08 21:27:50T-Scenario主要更新 添加 Common模組，在遊戲和UI腳本上運行。 Common.WeaponOption 類，用於修改武器性能和統計資訊。 Game.Entity 衍生遊戲實體類別的基底類別。 Game.Monster 用於處理怪物實體的類，繼承自 Game.Entity 基類。 Game.Weapon 類，用於處理玩家武器實體。 Game.GetEntity 方法檢索具有給定實體索引的實體實例。 Game.RandomInt 和 Game.RandomFloat 方法用於隨機數生成器。 Game.KillAllMonsters 方法，殺死所有怪物。 Game.ENTITYTYPE、Game.MONSTERTYPE、Game.RENDERFX、Game.WEAPONCOLOR Game.THIRDPERSON_FIXED_PLANE表。 Game.Rule.OnRoundStartFinished 事件，在回合凍結時間結束時調用。 Game.Rule.OnPlayerJoiningSpawn 事件，在玩家首次生成時調用。 Game.Rule.OnLoadGameSave 事件，在載入&#x2F;導入遊戲保存數據時調用。 Game.Rule.OnClearGameSave 事件，在清除遊戲保存數據時調用。 Game.Rule.OnTakeDamage 事件，在實體受到傷害時調用。 Game.Rule.OnKilled 事件，在實體被殺死時調用。 Game.Rule.CanBuyWeapon 事件，當玩家即將在武器商店功能表中購買武器時調用。 Game.Rule.CanHaveWeaponInHand 事件，在玩家即將拾取武器實體時調用。 Game.Rule.OnGetWeapon 事件，在玩家拾取武器實體時調用。 Game.Rule.OnSwitchWeapon 事件，當玩家將當前武器切換到另一種武器時調用。 Game.Rule.PostFireWeapon 事件，在玩家發射當前武器時調用。 Game.Rule.OnReload 事件，在玩家重新載入武器彈藥時調用。 Game.Rule.PostFireWeapon 事件，在玩家完成重新裝填武器彈藥時調用。 Game.Player.gravity 字段，用於更改玩家的重力。 Game.Player.infiniteclip 字段，用於啟用&#x2F;禁用無限彈藥供應。 使用 Game.Player.SetFirstPersonView、Game.Player.SetThirdPersonView 和 Game.Player.SetThirdPersonFixedView 方法更改玩家的攝像機透視圖。 Game.Player.SetThirdPersonFixedPlane 方法，用於在使用固定的第三人稱攝像機時更改滑鼠指標光線投射。 新的武器庫存系統，可以保存遊戲，引入Game.Player.GetWeaponInvenList，Game.Player.SetWeaponInvenLockedUI，Game.Player.ShowWeaponInven，Game.Player.ToggleWeaponInven和Game.Player.ClearWeaponInven方法。 使用 Game.Player.GetPrimaryWeapon 和 Game.Player.GetSecondaryWeapon 方法檢索玩家的當前武器。 使用 Game.Player.SetBuymenuLockedUI 方法啟動殭屍場景樣式的 UI。 Game.Player.SetBuymenuLockedUI 方法自定義武器購物功能表外觀。 使用 Game.Player.Signal 方法和 UI 從伺服器發送 UI 信號。Event.OnSignal 事件。 新的鍵輸入事件，UI。Event.OnKeyDown 和 UI。Event.OnKeyUp。 改變 由於新添加了 Game.Entity 基類，Game.Player 的某些欄位將移動到該基類，並從該基類繼承。 1.4實現了遊戲保存 API。 添加 Game.Rule.CanSave 方法，用於檢查當前地圖是否支持遊戲保存。 使用 Game.Rule.SetGameSave 和 Game.Rule.GetGameSave 方法載入和保存共享遊戲保存數據。 使用 Game.Player.SetGameSave 和 Game.Player.GetGameSave 方法載入和保存玩家的遊戲保存數據。 使用 Game.Rule.OnReceiveGameSave 事件掛接遊戲保存載入事件。 使用 Game.Rule.OnGameSave 事件掛接遊戲保存事件。 1.3添加 將 aksha 殭屍模型添加到 Game.MODEL 表 （Game.MODEL.AKSHA_ZOMBIE &amp; Game.MODEL.AKSHA_ZOMBIE_HOST） 中。 固定 修復了UI中的拼寫錯誤。SyncValue.value。 1.2添加 使用 Game.Rule.OnRoundStart 和 UI 挂鉤新一輪開始的事件。Event.OnRoundStart 事件。 固定 修復了更改 Game.Player.team 字段並調用 Game.Player.Win 方法後，腳本在下一輪開始時重新啟動的問題。 1.1 添加 Game.SetTrigger 方法，用於（取消）啟動“設備控制腳本”塊。 Game.GetTriggerEntity 和 Game.GetScriptCaller，用於“Function Caller”塊調用的全域函數。 Game.WEAPONTYPE和Game.HITBOX表。 通過 Game.Player.team 欄位更改玩家的團隊。 通過 Game.Player.flinch 欄位更改玩家受到傷害時的剛度。 通過 Game.Player.knockback 字段更改玩家受到傷害時的擊退。 通過 Game.Player.model 欄位更改玩家的模型。 使用 Game.Rule.OnPlayerAttack 事件挂鉤玩家的承受傷害事件。 使用UI在UI腳本中檢索玩家的實體索引。PlayerIndex 方法。 通過UI檢索UI物件的配置。Box.Get 和 UI。Text.Get 方法。 使用 Game.GetTime 和 UI 檢索引擎時間。GetTime 方法。 Function Caller塊，用於調用在遊戲腳本中聲明的全域函數。 改變 在 Game.Rule.OnPlayerKilled 事件上添加了“weapontype”和“hitbox”參數。 在Game.Rule.Win和Game.Player.Win方法上添加了“exit”參數，以在下一輪開始時終止遊戲。 固定 玩家可以在 Game.Rule.OnPlayerKilled 事件中使用 Game.Player.Respawn 方法以程式設計方式正確重生。 1.0 首次發佈。"},{"title":"GameSave API","path":"/GFBlog/wiki/csolua/gamesave.html","content":"啟用遊戲保存功能通過分配地圖的 gamesave 組索引，可以使用 GameSave 功能來支援地圖。要禁用它，只需取消分配其遊戲保存組索引即可。 遊戲保存數據遊戲儲存資料有 2 種類型： 共用遊戲保存數據。 玩家遊戲保存數據。 共用的遊戲存檔數據將共用到同一存檔遊戲組索引上的所有地圖。 例如，將映射A和映射B分配給保存遊戲組索引1。然後，腳本編寫器使用 Game.Rule.SetGameSave 保存地圖A上的資料。之後，保存的數據將共用到兩個地圖，並可以使用 Game.Rule.GetGameSave 進行檢索。 同時在玩家遊戲保存數據時，會保存在特定玩家身上，共用到同一保存遊戲組索引上的所有地圖。 例如，將映射A和映射B分配給保存遊戲組索引1。然後，玩家Bob播放地圖A並使用 Game.Player.SetGameSave 保存數據。退出地圖A後，玩家”Bob”播放地圖B。然後，保存的數據將共用到兩個地圖，並可以使用玩家Bob的Game.Player.GetGameSave進行檢索。 保存並載入共用的遊戲保存數據會在遊戲開始時自動載入，並在遊戲結束時每 1 分鐘或結束時自動批量保存。 玩家遊戲保存數據可以自動載入，也可以在首次生成後按L手動載入，具體取決於 Common.SetAutoLoad 設置。 如果玩家沒有載入數據，它將每 1 分鐘或在遊戲結束時自動保存並被新資料覆蓋！ 普通玩家遊戲保存數據玩家數據會自動保存和載入一些常用數據以下是它們清單： healthmaxhealtharmormaxarmorcoinitems 目前血量血量最大值目前護甲護甲最大值Studio 金幣數量Studio 物品背包清單 由於上述數據是自動保存的，因此腳本編寫器無法使用 Game.Player.SetGameSave 方法覆蓋它們。但是，您可以使用 Game.Player.GetGameSave 方法檢索它們。"},{"path":"/GFBlog/wiki/csolua/index.html","content":"Modules 模組 Common 該模組包含用於在客戶端和伺服器上一起運行的腳本的功能。 應該安裝在「 project.json 」的game和ui陣列中。 Game 此模組包含僅在伺服器上運行的腳本的功能。 應安裝在「project.json」的game陣列中。 UI 此模組包含僅在用戶端上運行的腳本的功能。 應安裝在「project.json」的ui陣列中。 Classes 類別Common Common.WeaponOption 通用武器選項類。 這將影響所有具有給定武器ID的生成武器。 例如，如果您修改了 AK-47 的 WeaponOption，遊戲中使用的所有 AK-47 都將反映修改後的統計數據。 Game Game.EntityGame.EntityBlockGame.RuleGame.MonsterGame.PlayerGame.SyncValueGame.Weapon 遊戲實體的基礎類Studio 裝置方塊類遊戲規則類怪物類玩家類數據同步類武器類 UI UI.SyncValueUI.BoxUI.TextUI.Event 數據同步類矩形UI類事件回調文字UI類 Topics 主題 更新日誌 遊戲存檔 Examples 範例 scenariot_common.lua scenariot_game.lua scenariot_ui.lua tdm_game.lua tdm_ui.lua"},{"title":"啟示錄TX Common","path":"/GFBlog/wiki/csolua/scenariot_common.html","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361--[[ 修改遊戲選項 ]]Common.UseWeaponInven(true) -- 使用武器庫存功能Common.SetSaveCurrentWeapons(true) -- 設定保存目前裝備的武器Common.SetSaveWeaponInven(true) -- 設定保存武器庫存內容（必須先設定UseWeaponInven）Common.SetAutoLoad(true) -- 自動載入已儲存的訊息Common.DisableWeaponParts(true) -- 停用武器零件功能Common.DisableWeaponEnhance(true) -- 停用武器增強功能Common.DontGiveDefaultItems(true) -- 遊戲開始時不提供預設武器。Common.DontCheckTeamKill(true) -- 即使有團隊擊殺，也會被視為普通擊殺。Common.UseScenarioBuymenu(true) -- 讓商店使用場景商店櫥窗Common.SetNeedMoney(true) -- 設定購買槍枝時的金錢需求。Common.UseAdvancedMuzzle(true) -- 開火時以新形狀繪製槍口（忽略比例）Common.SetMuzzleScale(1.0) -- 設定射擊時的槍口尺寸Common.SetBloodScale(2) -- 修改命中時血量效果的大小Common.SetGunsparkScale(10) -- 修改子彈擊中牆壁等時的效果大小。Common.SetHitboxScale(2.5) -- 修改碰撞箱大小Common.SetMouseoverOutline(true, &#123;r = 255, g = 0, b = 0&#125;) -- 當您將滑鼠停留在實體（例如怪物）上時，讓輪廓可見。Common.SetUnitedPrimaryAmmoPrice(50) -- 將所有主要武器的每個彈匣的價格統一為此值。Common.SetUnitedSecondaryAmmoPrice(0) -- 將所有輔助武器的每個彈匣的價格統一為此值。--[[ 公共常數聲明 ]]-- 比較實際值時使用EPSILON = 0.00001-- 從 UI 發送到game的訊號SignalToGame = &#123;\topenWeaponInven = 1,&#125;-- 訊號從game發送到 UISignalToUI = &#123;\treloadStarted = 1,\treloadFinished = 2&#125;-- 遊戲中使用的武器類別WeaponGrade = &#123;\tnormal = 1,\trare = 2,\tunique = 3,\tlegend = 4,\tEND = 4&#125;-- 商店武器列表BuymenuWeaponList =\t&#123;\tCommon.WEAPON.P228,\tCommon.WEAPON.DualBeretta,\tCommon.WEAPON.FiveSeven,\tCommon.WEAPON.Glock18C,\tCommon.WEAPON.USP45,\tCommon.WEAPON.DesertEagle50C,\tCommon.WEAPON.DualInfinity,\tCommon.WEAPON.Galil,\tCommon.WEAPON.FAMAS,\tCommon.WEAPON.M4A1,\tCommon.WEAPON.AK47,\tCommon.WEAPON.OICW,\tCommon.WEAPON.MAC10,\tCommon.WEAPON.UMP45,\tCommon.WEAPON.MP5,\tCommon.WEAPON.TMP,\tCommon.WEAPON.P90,\tCommon.WEAPON.MP7A1ExtendedMag,\tCommon.WEAPON.Needler,\tCommon.WEAPON.M3,\tCommon.WEAPON.XM1014,\tCommon.WEAPON.DoubleBarrelShotgun,\tCommon.WEAPON.WinchesterM1887,\tCommon.WEAPON.USAS12,\tCommon.WEAPON.FireVulcan,\tCommon.WEAPON.M249,\tCommon.WEAPON.MG3,\tCommon.WEAPON.M134Minigun,\tCommon.WEAPON.K3,\tCommon.WEAPON.QBB95,\tCommon.WEAPON.M32MGL,\tCommon.WEAPON.Leviathan,\tCommon.WEAPON.Salamander,\tCommon.WEAPON.RPG7&#125;-- 設定商店武器清單（需要UseScenarioBuymenu設定）Common.SetBuymenuWeaponList(BuymenuWeaponList)-- 遊戲中使用的所有武器列表WeaponList = &#123;\t-- 副武器列表\tCommon.WEAPON.P228,\tCommon.WEAPON.DualBeretta,\tCommon.WEAPON.FiveSeven,\tCommon.WEAPON.Glock18C,\tCommon.WEAPON.USP45,\tCommon.WEAPON.DesertEagle50C,\tCommon.WEAPON.DualInfinity,\tCommon.WEAPON.DualInfinityCustom,\tCommon.WEAPON.DualInfinityFinal,\tCommon.WEAPON.SawedOffM79,\tCommon.WEAPON.Cyclone,\tCommon.WEAPON.AttackM950,\tCommon.WEAPON.DesertEagle50CGold,\tCommon.WEAPON.ThunderGhostWalker,\tCommon.WEAPON.PythonDesperado,\tCommon.WEAPON.DesertEagleCrimsonHunter,\tCommon.WEAPON.DualBerettaGunslinger,\t-- 步槍清單\tCommon.WEAPON.Galil,\tCommon.WEAPON.FAMAS,\tCommon.WEAPON.M4A1,\tCommon.WEAPON.SG552,\tCommon.WEAPON.AK47,\tCommon.WEAPON.AUG,\tCommon.WEAPON.AN94,\tCommon.WEAPON.M16A4,\tCommon.WEAPON.AK47Custom,\tCommon.WEAPON.HK416,\tCommon.WEAPON.AK74U,\tCommon.WEAPON.AKM,\tCommon.WEAPON.L85A2,\tCommon.WEAPON.FNFNC,\tCommon.WEAPON.TAR21,\tCommon.WEAPON.SCAR,\tCommon.WEAPON.SKULL4,\tCommon.WEAPON.OICW,\tCommon.WEAPON.PlasmaGun,\tCommon.WEAPON.StunRifle,\tCommon.WEAPON.StarChaserAR,\tCommon.WEAPON.CompoundBow,\tCommon.WEAPON.LightningAR2,\tCommon.WEAPON.Ethereal,\tCommon.WEAPON.LightningAR1,\tCommon.WEAPON.F2000,\tCommon.WEAPON.Crossbow,\tCommon.WEAPON.CrossbowAdvance,\tCommon.WEAPON.M4A1DarkKnight,\tCommon.WEAPON.AK47Paladin,\t-- 衝鋒槍列表\tCommon.WEAPON.MAC10,\tCommon.WEAPON.UMP45,\tCommon.WEAPON.MP5,\tCommon.WEAPON.TMP,\tCommon.WEAPON.P90,\tCommon.WEAPON.MP7A1ExtendedMag,\tCommon.WEAPON.DualKriss,\tCommon.WEAPON.KrissSuperV,\tCommon.WEAPON.DualMP7A1,\tCommon.WEAPON.Tempest,\tCommon.WEAPON.TMPDragon,\tCommon.WEAPON.P90Lapin,\tCommon.WEAPON.DualUZI,\tCommon.WEAPON.Needler,\tCommon.WEAPON.InfinityLaserFist,\t-- 霰彈槍清單\tCommon.WEAPON.M3,\tCommon.WEAPON.XM1014,\tCommon.WEAPON.DoubleBarrelShotgun,\tCommon.WEAPON.WinchesterM1887,\tCommon.WEAPON.USAS12,\tCommon.WEAPON.JackHammer,\tCommon.WEAPON.TripleBarrelShotgun,\tCommon.WEAPON.SPAS12Maverick,\tCommon.WEAPON.FireVulcan,\tCommon.WEAPON.BALROGXI,\tCommon.WEAPON.BOUNCER,\tCommon.WEAPON.FlameJackhammer,\tCommon.WEAPON.RailCannon,\tCommon.WEAPON.LightningSG1,\tCommon.WEAPON.USAS12CAMO,\tCommon.WEAPON.WinchesterM1887Gold,\tCommon.WEAPON.UTS15PinkGold,\tCommon.WEAPON.Volcano,\t-- 機槍清單\tCommon.WEAPON.M249,\tCommon.WEAPON.MG3,\tCommon.WEAPON.M134Minigun,\tCommon.WEAPON.MG36,\tCommon.WEAPON.MK48,\tCommon.WEAPON.K3,\tCommon.WEAPON.QBB95,\tCommon.WEAPON.QBB95AdditionalMag,\tCommon.WEAPON.BALROGVII,\tCommon.WEAPON.MG3CSOGSEdition,\tCommon.WEAPON.CHARGER7,\tCommon.WEAPON.ShiningHeartRod,\tCommon.WEAPON.Coilgun,\tCommon.WEAPON.Aeolis,\tCommon.WEAPON.BroadDivine,\tCommon.WEAPON.LaserMinigun,\tCommon.WEAPON.M249Phoenix,\t-- 裝備武器清單\tCommon.WEAPON.M32MGL,\tCommon.WEAPON.PetrolBoomer,\tCommon.WEAPON.Slasher,\tCommon.WEAPON.Eruptor,\tCommon.WEAPON.Leviathan,\tCommon.WEAPON.Salamander,\tCommon.WEAPON.RPG7,\tCommon.WEAPON.M32MGLVenom,\tCommon.WEAPON.Stinger,\tCommon.WEAPON.MagnumDrill,\tCommon.WEAPON.GaeBolg,\tCommon.WEAPON.Ripper,\tCommon.WEAPON.BlackDragonCannon,\tCommon.WEAPON.Guillotine&#125;--[[ 修改每種武器類型的屬性 ]]-- 次要武器屬性option = Common.GetWeaponOption(Common.WEAPON.P228)option.price = 100 -- 武器購買價格option.damage = 1.0 -- 當與 Weapon 類別一起設定時，兩者都會相乘。option.penetration = 1.0 -- 滲透率option.rangemod = 1.0 -- 基於距離的傷害衰減率option.cycletime = 1.0 -- 開火率option.reloadtime = 1.0 -- 重新載入速度option.accuracy = 1.0 -- 準確度option.spread = 1.0 -- 執行操作時準確度降低的程度option:SetBulletColor(&#123;r = 255, g = 255, b = 50&#125;); -- 開槍時，會出現指定顏色的射擊路徑。option.user.grade = WeaponGrade.normal -- 預先定義每種武器類型的最低等級option.user.level = 1 -- 購買武器時的等級限制-- 武器屬性詳細設定：武器id、價格、等級、可用等級、R、G、Bfunction SetOption(weaponid, price, grade, level, red, green, blue)\toption = Common.GetWeaponOption(weaponid)\toption.price = price\toption.user.grade = grade\toption.user.level = level\tif red ~= nil then option:SetBulletColor(&#123;r = red, g = green, b = blue&#125;);\tendendSetOption(Common.WEAPON.DualBeretta, 100, WeaponGrade.normal, 3, 255, 255, 50)SetOption(Common.WEAPON.FiveSeven, 100, WeaponGrade.normal, 1, 255, 255, 50)SetOption(Common.WEAPON.Glock18C, 100, WeaponGrade.normal, 1, 255, 255, 50)SetOption(Common.WEAPON.USP45, 100, WeaponGrade.normal, 1, 255, 255, 50)SetOption(Common.WEAPON.DesertEagle50C, 500, WeaponGrade.normal, 5, 255, 255, 50)SetOption(Common.WEAPON.DualInfinity, 500, WeaponGrade.normal, 3, 255, 255, 50)SetOption(Common.WEAPON.DualInfinityCustom,\t800, WeaponGrade.normal, 4, 255, 255, 50)SetOption(Common.WEAPON.DualInfinityFinal,\t1500, WeaponGrade.normal, 7, 255, 255, 50)SetOption(Common.WEAPON.SawedOffM79, 1000, WeaponGrade.normal, 5)SetOption(Common.WEAPON.Cyclone, 2000, WeaponGrade.unique, 8)SetOption(Common.WEAPON.AttackM950, 700, WeaponGrade.unique, 5, 255, 255, 50)SetOption(Common.WEAPON.DesertEagle50CGold,\t700, WeaponGrade.unique, 5, 255, 255, 50)SetOption(Common.WEAPON.ThunderGhostWalker, 5000, WeaponGrade.legend, 7)SetOption(Common.WEAPON.PythonDesperado, 8000, WeaponGrade.legend, 15, 255, 255, 50)SetOption(Common.WEAPON.DesertEagleCrimsonHunter,\t7000, WeaponGrade.legend, 12, 255, 255, 50)SetOption(Common.WEAPON.DualBerettaGunslinger, 20000, WeaponGrade.legend, 30, 255, 255, 50)-- 步槍屬性SetOption(Common.WEAPON.Galil, 500, WeaponGrade.normal, 2, 255, 128, 0)SetOption(Common.WEAPON.FAMAS, 500, WeaponGrade.normal, 2, 255, 128, 0)SetOption(Common.WEAPON.M4A1, 700, WeaponGrade.normal, 5, 255, 128, 0)SetOption(Common.WEAPON.SG552, 700, WeaponGrade.normal, 5, 255, 128, 0)SetOption(Common.WEAPON.AK47, 700, WeaponGrade.normal, 5, 255, 128, 0)SetOption(Common.WEAPON.AUG, 700, WeaponGrade.normal, 5, 255, 128, 0)SetOption(Common.WEAPON.AN94, 500, WeaponGrade.normal, 1, 255, 128, 0)SetOption(Common.WEAPON.M16A4, 500, WeaponGrade.normal, 1, 255, 128, 0)SetOption(Common.WEAPON.AK47Custom,\t15000, WeaponGrade.normal, 20, 255, 128, 0)SetOption(Common.WEAPON.HK416, 500, WeaponGrade.normal, 2, 255, 128, 0)SetOption(Common.WEAPON.AK74U, 500, WeaponGrade.normal, 2, 255, 128, 0)SetOption(Common.WEAPON.AKM, 500, WeaponGrade.normal, 2, 255, 128, 0)SetOption(Common.WEAPON.L85A2, 500, WeaponGrade.normal, 2, 255, 128, 0)SetOption(Common.WEAPON.FNFNC, 500, WeaponGrade.normal, 2, 255, 128, 0)SetOption(Common.WEAPON.TAR21, 500, WeaponGrade.normal, 2, 255, 128, 0)SetOption(Common.WEAPON.SCAR, 500, WeaponGrade.normal, 2, 255, 128, 0)SetOption(Common.WEAPON.SKULL4, 5000, WeaponGrade.rare, 10, 255, 128, 0)SetOption(Common.WEAPON.OICW, 1000, WeaponGrade.unique, 5, 255, 128, 0)SetOption(Common.WEAPON.PlasmaGun, 1000, WeaponGrade.unique, 5, 255, 128, 0)SetOption(Common.WEAPON.StunRifle, 7000, WeaponGrade.unique, 15, 255, 128, 0)SetOption(Common.WEAPON.StarChaserAR, 8000, WeaponGrade.unique, 20, 255, 128, 0)SetOption(Common.WEAPON.CompoundBow, 1000, WeaponGrade.unique, 5, 255, 128, 0)SetOption(Common.WEAPON.LightningAR2, 1000, WeaponGrade.unique, 5, 255, 128, 0)SetOption(Common.WEAPON.Ethereal, 1000, WeaponGrade.unique, 5, 255, 128, 0)SetOption(Common.WEAPON.LightningAR1, 1000, WeaponGrade.unique, 5, 255, 128, 0)SetOption(Common.WEAPON.F2000, 1000, WeaponGrade.unique, 5, 255, 128, 0)SetOption(Common.WEAPON.Crossbow, 1000, WeaponGrade.legend, 8, 255, 128, 0)SetOption(Common.WEAPON.CrossbowAdvance,\t2600, WeaponGrade.legend, 8, 255, 128, 0)SetOption(Common.WEAPON.M4A1DarkKnight, 20000, WeaponGrade.legend, 25, 255, 128, 0)SetOption(Common.WEAPON.AK47Paladin, 20000, WeaponGrade.legend, 25, 255, 128, 0)-- 衝鋒槍屬性SetOption(Common.WEAPON.MAC10, 300, WeaponGrade.normal, 2, 128, 255, 255)SetOption(Common.WEAPON.UMP45, 300, WeaponGrade.normal, 2, 128, 255, 255)SetOption(Common.WEAPON.MP5, 300, WeaponGrade.normal, 3, 128, 255, 255)SetOption(Common.WEAPON.TMP, 300, WeaponGrade.normal, 1, 128, 255, 255)SetOption(Common.WEAPON.P90, 300, WeaponGrade.normal, 1, 128, 255, 255)SetOption(Common.WEAPON.MP7A1ExtendedMag, 2000, WeaponGrade.normal, 10, 128, 255, 255)SetOption(Common.WEAPON.DualKriss, 500, WeaponGrade.normal, 5, 128, 255, 255)SetOption(Common.WEAPON.KrissSuperV, 300, WeaponGrade.normal, 3, 128, 255, 255)SetOption(Common.WEAPON.DualMP7A1, 500, WeaponGrade.normal, 5, 128, 255, 255)SetOption(Common.WEAPON.Tempest, 1000, WeaponGrade.unique, 6, 128, 255, 255)SetOption(Common.WEAPON.TMPDragon, 800, WeaponGrade.unique, 3, 128, 255, 255)SetOption(Common.WEAPON.P90Lapin, 800, WeaponGrade.unique, 3, 128, 255, 255)SetOption(Common.WEAPON.DualUZI, 1200, WeaponGrade.unique, 4, 128, 255, 255)SetOption(Common.WEAPON.Needler, 1000, WeaponGrade.unique, 3, 128, 255, 255)SetOption(Common.WEAPON.InfinityLaserFist, 20000, WeaponGrade.legend, 25)-- 霰彈槍屬性SetOption(Common.WEAPON.M3, 300, WeaponGrade.normal, 3, 50, 255, 50)SetOption(Common.WEAPON.XM1014, 500, WeaponGrade.normal, 4, 50, 255, 50)SetOption(Common.WEAPON.DoubleBarrelShotgun,\t200, WeaponGrade.normal, 1, 50, 255, 50)SetOption(Common.WEAPON.WinchesterM1887, 500, WeaponGrade.normal, 4, 50, 255, 50)SetOption(Common.WEAPON.USAS12, 700, WeaponGrade.normal, 5, 50, 255, 50)SetOption(Common.WEAPON.JackHammer, 500, WeaponGrade.normal, 3, 50, 255, 50)SetOption(Common.WEAPON.TripleBarrelShotgun,\t600, WeaponGrade.normal, 4, 50, 255, 50)SetOption(Common.WEAPON.SPAS12Maverick, 1200, WeaponGrade.rare, 7, 50, 255, 50)SetOption(Common.WEAPON.FireVulcan, 3000, WeaponGrade.rare, 5, 50, 255, 50)SetOption(Common.WEAPON.BALROGXI, 10000, WeaponGrade.rare, 12, 50, 255, 50)SetOption(Common.WEAPON.BOUNCER, 20000, WeaponGrade.unique, 14)SetOption(Common.WEAPON.FlameJackhammer, 3000, WeaponGrade.unique, 5, 50, 255, 50)SetOption(Common.WEAPON.RailCannon, 3000, WeaponGrade.unique, 5, 50, 255, 50)SetOption(Common.WEAPON.LightningSG1, 3000, WeaponGrade.unique, 5, 50, 255, 50)SetOption(Common.WEAPON.USAS12CAMO, 3000, WeaponGrade.unique, 5, 50, 255, 50)SetOption(Common.WEAPON.WinchesterM1887Gold,\t3000, WeaponGrade.unique, 5, 50, 255, 50)SetOption(Common.WEAPON.UTS15PinkGold, 3000, WeaponGrade.unique, 5, 50, 255, 50)SetOption(Common.WEAPON.Volcano, 15000, WeaponGrade.legend, 14, 50, 255, 50)-- 機槍屬性SetOption(Common.WEAPON.M249, 600, WeaponGrade.normal, 3, 255, 50, 255)SetOption(Common.WEAPON.MG3, 1500, WeaponGrade.normal, 7, 255, 50, 255)SetOption(Common.WEAPON.M134Minigun,\t1000, WeaponGrade.normal, 3, 255, 50, 255)SetOption(Common.WEAPON.MG36, 1000, WeaponGrade.normal, 5, 255, 50, 255)SetOption(Common.WEAPON.MK48, 1000, WeaponGrade.normal, 5, 255, 50, 255)SetOption(Common.WEAPON.K3, 600, WeaponGrade.normal, 5, 255, 50, 255)SetOption(Common.WEAPON.QBB95, 800, WeaponGrade.normal, 7, 255, 50, 255)SetOption(Common.WEAPON.QBB95AdditionalMag, 1000, WeaponGrade.normal, 7, 255, 50, 255)SetOption(Common.WEAPON.BALROGVII, 2500, WeaponGrade.rare, 7, 255, 50, 255)SetOption(Common.WEAPON.MG3CSOGSEdition, 2500, WeaponGrade.rare, 7, 255, 50, 255)SetOption(Common.WEAPON.CHARGER7, 5000, WeaponGrade.rare, 7, 255, 50, 255)SetOption(Common.WEAPON.ShiningHeartRod, 8000, WeaponGrade.unique, 12, 255, 50, 255)SetOption(Common.WEAPON.Coilgun, 5000, WeaponGrade.unique, 7, 255, 50, 255)SetOption(Common.WEAPON.Aeolis, 5000, WeaponGrade.unique, 7, 255, 50, 255)SetOption(Common.WEAPON.BroadDivine, 7000, WeaponGrade.unique, 10, 255, 50, 255)SetOption(Common.WEAPON.LaserMinigun, 7000, WeaponGrade.unique, 10)SetOption(Common.WEAPON.M249Phoenix, 30000, WeaponGrade.legend, 25, 255, 50, 255)-- 裝備武器屬性SetOption(Common.WEAPON.M32MGL, 3000, WeaponGrade.normal, 5)SetOption(Common.WEAPON.PetrolBoomer,\t3000, WeaponGrade.normal, 5)SetOption(Common.WEAPON.Slasher, 3000, WeaponGrade.normal, 5)SetOption(Common.WEAPON.Eruptor, 300, WeaponGrade.normal, 1)SetOption(Common.WEAPON.Leviathan, 2000, WeaponGrade.normal, 7)SetOption(Common.WEAPON.Salamander, 2000, WeaponGrade.normal, 7)SetOption(Common.WEAPON.RPG7, 1200, WeaponGrade.normal, 3)SetOption(Common.WEAPON.M32MGLVenom,\t5000, WeaponGrade.unique, 15)SetOption(Common.WEAPON.Stinger, 3000, WeaponGrade.unique, 3)SetOption(Common.WEAPON.MagnumDrill,\t20000, WeaponGrade.legend, 25, 50, 50, 255)SetOption(Common.WEAPON.GaeBolg, 10000, WeaponGrade.legend, 15)SetOption(Common.WEAPON.Ripper, 15000, WeaponGrade.legend, 20)SetOption(Common.WEAPON.BlackDragonCannon, 10000, WeaponGrade.legend, 7)SetOption(Common.WEAPON.Guillotine, 10000, WeaponGrade.legend, 10)"},{"title":"啟示錄TX UI","path":"/GFBlog/wiki/csolua/scenariot_ui.html","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384screen = UI.ScreenSize()center = &#123;x = screen.width / 2, y = screen.height / 2&#125;--[[ 顯示庫存密鑰 ]]weaponInvenKeyText = UI.Text.Create()weaponInvenKeyText:Set(&#123;text = &#x27;인벤토리 : [B]&#x27;, font=&#x27;small&#x27;, align=&#x27;right&#x27;, x = center.x + 80, y = screen.height - 25, width = 185, height = 30, r = 255, g = 200, b = 0, a = 100&#125;)--[[ 載入中 ui ]]reloadingInit = falsereloadingBG = UI.Box.Create()reloadingGauge = UI.Box.Create()reloadingText = UI.Text.Create()reloadingBG:Hide()reloadingGauge:Hide()reloadingText:Hide()reloadTime = 0 -- 重新載入所需時間reloadStartTime = 0 -- 重新載入開始時間reloadTimeSync = UI.SyncValue.Create(&quot;reloadTime&quot;)function reloadTimeSync:OnSync()\treloadTime = self.valueendfunction UI.Event:OnUpdate(time)\tif reloadingBG:IsVisible() and reloadTime &gt; EPSILON then if reloadStartTime &lt; EPSILON then reloadStartTime = time else -- 透過計算自載入開始以來經過的時間來變更儀表的寬度。 local diff = time - reloadStartTime local ratio = diff / reloadTime if ratio &gt; 1 then reloadingBG:Hide() reloadingGauge:Hide() reloadingText:Hide() reloadingGauge:Set(&#123;width = 0&#125;) reloadTime = 0 else reloadingGauge:Set(&#123;width = 100 * ratio&#125;) end end\tendend--[[ 事件函數 ]]-- 按鍵時的事件函數function UI.Event:OnKeyDown(inputs)\tif inputs[UI.KEY.B] then UI.Signal(SignalToGame.openWeaponInven)\tendend-- 透過game傳遞訊息function UI.Event:OnSignal(signal)\tif signal == SignalToUI.reloadStarted then -- 第一次打開時填寫資料 if reloadingInit == false then reloadingInit = true reloadingBG:Set(&#123;x = center.x - 50, y = center.y - 20, width = 100, height = 27, r = 25, g = 25, b = 25, a = 220&#125;) reloadingGauge:Set(&#123;x = center.x - 50, y = center.y - 20, width = 100, height = 27, r = 100, g = 120, b = 150, a = 220&#125;) reloadingText:Set(&#123;text = &#x27;장전중&#x27;, font=&#x27;small&#x27;, align=&#x27;center&#x27;, x = center.x - 50, y = center.y - 4, width = 100, height = 20, r = 255, g = 255, b = 255&#125;) end reloadingBG:Show() reloadingGauge:Show() reloadingText:Show() reloadingGauge:Set(&#123;width = 0&#125;) reloadStartTime = 0 reloadTime = 0\telseif signal == SignalToUI.reloadFinished then reloadingBG:Hide() reloadingGauge:Hide() reloadingText:Hide() reloadingGauge:Set(&#123;width = 0&#125;) reloadTime = 0\tendend"},{"title":"團隊死鬥 Game","path":"/GFBlog/wiki/csolua/tdm_game.html","content":"12345678910111213141516171819202122232425262728293031323334353637383940-- 團隊死亡競賽範例(game)local TDM = Game.RuleTDM.name = &quot;팀데스매치&quot;TDM.desc = &quot;스크립트로 만드는 팀데 모드&quot;-- 地圖可以被破壞TDM.breakable = true-- 目標分數local MaxKill = Game.SyncValue.Create(&quot;MaxKill&quot;)MaxKill.value = 30-- 團隊得分local Score = &#123;&#125;Score[Game.TEAM.CT] = Game.SyncValue.Create(&quot;ScoreCT&quot;)Score[Game.TEAM.CT].value = 0Score[Game.TEAM.TR] = Game.SyncValue.Create(&quot;ScoreTR&quot;)Score[Game.TEAM.TR].value = 0function TDM:OnPlayerSpawn(player) player:ShowBuymenu()endfunction TDM:OnPlayerKilled(victim, killer) -- 自殺、跌倒等。 if killer == nil then return end -- 殺死玩家的隊伍得 1 分 local killer_team = killer.team local point = Score[killer_team] point.value = point.value + 1 -- 如果你超過了目標，你就贏了！ if (point.value &gt;= MaxKill.value) then self:Win(killer_team) endend"},{"title":"團隊死鬥 UI","path":"/GFBlog/wiki/csolua/tdm_ui.html","content":"1234567891011121314151617181920212223242526272829303132333435363738394041-- 團隊死亡競賽範例(ui)-- 需要在伺服器上同步的分數變數ScoreCT = UI.SyncValue.Create(&quot;ScoreCT&quot;)ScoreTR = UI.SyncValue.Create(&quot;ScoreTR&quot;)MaxKill = UI.SyncValue.Create(&quot;MaxKill&quot;)-- 創建記分牌screen = UI.ScreenSize()center = &#123;x = screen.width / 2, y = screen.height / 2&#125;scoreBG = UI.Box.Create()scoreBG:Set(&#123;x = center.x - 100, y = 0, width = 200, height = 50, r = 255, g = 255, b = 255, a = 150&#125;)goalBG = UI.Box.Create()goalBG:Set(&#123;x = center.x - 50, y = 0, width = 100, height = 50, r = 40, g = 40, b = 40, a = 150&#125;)goalLabel = UI.Text.Create()goalLabel:Set(&#123;text=&#x27;00&#x27;, font=&#x27;large&#x27;, align=&#x27;center&#x27;, x = center.x - 50, y = 10, width = 100, height = 50, r = 80, g = 255, b = 80&#125;)ctLabel = UI.Text.Create()ctLabel:Set(&#123;text=&#x27;00&#x27;, font=&#x27;medium&#x27;, align=&#x27;left&#x27;, x = center.x - 95, y = 20, width = 50, height = 50, r = 80, g = 80, b = 255&#125;)trLabel = UI.Text.Create()trLabel:Set(&#123;text=&#x27;00&#x27;, font=&#x27;medium&#x27;, align=&#x27;right&#x27;, x = center.x + 45, y = 20, width = 50, height = 50, r = 255, g = 80, b = 80&#125;)-- 每次同步變數時，記分板都會更新。function ScoreCT:OnSync() local str = string.format(&quot;%02d&quot;, self.value) ctLabel:Set(&#123;text = str&#125;)endfunction ScoreTR:OnSync() local str = string.format(&quot;%02d&quot;, self.value) trLabel:Set(&#123;text = str&#125;)endfunction MaxKill:OnSync() local str = string.format(&quot;%02d&quot;, self.value) goalLabel:Set(&#123;text = str&#125;)end"},{"title":"啟示錄TX Game","path":"/GFBlog/wiki/csolua/scenariot_game.html","content":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121--[[ 事先定義game中所需的常數和變數 ]]players = &#123;&#125;difficultySelectPlayer = 0 -- 玩家索引選擇或選擇難度級別-- 設定武器和怪物能力等時所使用的標準等級。MonsterLevel = 1 -- 怪物等級LEVEL_MIN = 1 -- 最低玩家等級LEVEL_MAX = 99 -- 玩家最高等級WEAPONLEVEL_MAX = 60 -- 武器最大等級mapDifficulty = SignalToGame.difficulty0 -- 目前地圖難度-- 武器和怪物的各種能力是根據其等級乘以以下數值來使用的。LevelRatio = &#123;\t1.000,\t1.050,\t1.103,\t1.158,\t1.216,\t1.276,\t1.340,\t1.407,\t1.477,\t1.551,\t1.629,\t1.710,\t1.796,\t1.886,\t1.980,\t2.079,\t2.183,\t2.292,\t2.407,\t2.527,\t2.653,\t2.786,\t2.925,\t3.072,\t3.225,\t3.386,\t3.556,\t3.733,\t3.920,\t4.116,\t4.322,\t4.538,\t4.765,\t5.003,\t5.253,\t5.516,\t5.792,\t6.081,\t6.385,\t6.705,\t7.040,\t7.392,\t7.762,\t8.150,\t8.557,\t8.985,\t9.434,\t9.906,\t10.401,\t10.921,\t11.467,\t12.041,\t12.643,\t13.275,\t13.939,\t14.636,\t15.367,\t16.136,\t16.943,\t17.790,\t18.679,\t19.613,\t20.594,\t21.623,\t22.705,\t23.840,\t25.032,\t26.283,\t27.598,\t28.978,\t30.426,\t31.948,\t33.545,\t35.222,\t36.984,\t38.833,\t40.774,\t42.813,\t44.954,\t47.201,\t49.561,\t52.040,\t54.641,\t57.374,\t60.242,\t63.254,\t66.417,\t69.738,\t73.225,\t76.886,\t80.730,\t84.767,\t89.005,\t93.455,\t98.128,\t103.035,\t108.186,\t113.596,\t119.276,&#125;-- 武器等級判定機率WeaponGradeProb = &#123;\t1.0,\t0.2,\t0.05,\t0.005&#125;-- 按武器類別劃分的基本傷害WeaponGradeDamage = &#123;\t1.0,\t1.25,\t1.5,\t2.0&#125;-- 武器隨機傷害（如果是0.15，則在0.85到1.15之間隨機產生）WeaponRandomDamage = 0.15-- 按武器等級劃分的傷害WeaponLevelDamage = 1.0-- 保存遊戲中使用的怪物類型MonsterTypes = &#123;\tGame.MONSTERTYPE.NORMAL0,\tGame.MONSTERTYPE.NORMAL1,\tGame.MONSTERTYPE.NORMAL2,\tGame.MONSTERTYPE.NORMAL3,\tGame.MONSTERTYPE.NORMAL4,\tGame.MONSTERTYPE.NORMAL5,\tGame.MONSTERTYPE.NORMAL6,\tGame.MONSTERTYPE.RUNNER0,\tGame.MONSTERTYPE.RUNNER1,\tGame.MONSTERTYPE.RUNNER2,\tGame.MONSTERTYPE.RUNNER3,\tGame.MONSTERTYPE.RUNNER4,\tGame.MONSTERTYPE.RUNNER5,\tGame.MONSTERTYPE.RUNNER6,\tGame.MONSTERTYPE.HEAVY1,\tGame.MONSTERTYPE.HEAVY2,\tGame.MONSTERTYPE.A101AR,\tGame.MONSTERTYPE.A104RL,&#125;-- 遊戲中使用的怪物類別的定義MonsterGrade = &#123;\tnormal = 1,\trare = 2,\tunique = 3,\tlegend = 4,\tEND = 4&#125;-- 統計每個怪物組（組）是否死亡的表格monsterGroupCnt = &#123;&#125;-- 怪物波管理表（與怪物生成器類似的行為）monsterWaveCnt = &#123;&#125;monsterWavePosition = &#123;&#125;-- 是否對付wave怪WaveFuncState = &#123;\tenable = 1, -- 啟用wave\tdisable = 3, -- 禁用wave&#125;monsterWaveFuncState = WaveFuncState.enable-- 怪物等級判定機率MonsterGradeProb = &#123;\t1.0,\t0.3,\t0.1,\t0.01&#125;-- 不同怪物等級的武器掉落機率（最大 1.0）WeaponDropProb = &#123;\t0.035,\t0.08,\t0.08,\t1&#125;-- 為每個怪物等級設定數值MonsterLevelVar = &#123;\tnormal =\t&#123;hpMin = 30, hpMax = 60, armorMin = 5, armorMax = 30, damageMin = 10, damageMax = 20, coinMin = 1, coinMax = 5&#125;,\trunner =\t&#123;hpMin = 20, hpMax = 50, armorMin = 0, armorMax = 20, damageMin = 10, damageMax = 30, coinMin = 3, coinMax = 8&#125;,\theavy = &#123;hpMin = 150, hpMax = 250, armorMin = 20, armorMax = 55, damageMin = 20, damageMax = 40, coinMin = 10, coinMax = 15&#125;,\ta101ar =\t&#123;hpMin = 150, hpMax = 250, armorMin = 30, armorMax = 50, damageMin = 4, damageMax = 4, coinMin = 20, coinMax = 25&#125;,\ta104rl =\t&#123;hpMin = 150, hpMax = 250, armorMin = 30, armorMax = 50, damageMin = 17, damageMax = 17, coinMin = 20, coinMax = 25&#125;,\tetc = &#123;hpMin = 20, hpMax = 50, armorMin = 0, armorMax = 20, damageMin = 10, damageMax = 35, coinMin = 3, coinMax = 8&#125;,&#125;-- 基於怪物生命值的經驗值（exp == hp * MonsterExpMult）MonsterExpMult = 0.6-- 設定每個等級的最高等級和所需經驗PlayerRequireExp = &#123;\t87,\t360,\t864,\t1584,\t2625,\t3996,\t5586,\t7680,\t10206,\t13200,\t17061,\t21168,\t25857,\t31752,\t38475,\t45312,\t53754,\t64152,\t74727,\t87600,\t100548,\t116160,\t133308,\t152064,\t174375,\t196716,\t223074,\t251664,\t285099,\t318600,\t357492,\t402432,\t447579,\t499392,\t554925,\t618192,\t685869,\t758100,\t839592,\t926400,\t1023729,\t1127196,\t1236981,\t1359072,\t1494450,\t1637784,\t1795917,\t1969920,\t2153697,\t2355000,\t2574990,\t2806752,\t3067428,\t3341736,\t3639075,\t3960768,\t4308174,\t4682688,\t5096184,\t5529600,\t5994531,\t6504048,\t7060851,\t7643136,\t8276775,\t8964648,\t9696240,\t10487232,\t11340702,\t12245100,\t13232625,\t14292288,\t15427455,\t16641564,\t17955000,\t19355376,\t20864151,\t22486464,\t24208839,\t26073600,\t28067958,\t30217656,\t32509191,\t34948368,\t37584450,\t40404348,\t43415784,\t46626624,\t50092404,\t53775900,\t57735132,\t61956480,\t66476214,\t71306520,\t76486875,\t82003968,\t87898878,\t94215240,\t100000000&#125;--[[ 怪物相關的用戶自訂函數 ]]-- 根據等級設定怪物能力function SetMonsterAttribute(monster, grade)\tif monster == nil then return\tend\tmonster.user.level = monsterLevel\tmonster.user.grade = grade\tmonster.applyKnockback = true -- 使怪物能夠受到擊退\tmonster.canJump = false -- 防止怪物跳躍\tmonster.viewDistance = 12 -- 發現敵人的視野範圍\tlocal levelVar\tif Game.MONSTERTYPE.NORMAL0 &lt;= monster.type and monster.type &lt;= Game.MONSTERTYPE.NORMAL6 then levelVar = MonsterLevelVar.normal\telseif Game.MONSTERTYPE.RUNNER0 &lt;= monster.type and monster.type &lt;= Game.MONSTERTYPE.RUNNER6 then levelVar = MonsterLevelVar.runner\telseif Game.MONSTERTYPE.HEAVY1 &lt;= monster.type and monster.type &lt;= Game.MONSTERTYPE.HEAVY2 then levelVar = MonsterLevelVar.heavy\telseif monster.type == Game.MONSTERTYPE.A101AR then levelVar = MonsterLevelVar.a101ar\telseif monster.type == Game.MONSTERTYPE.A104RL then levelVar = MonsterLevelVar.a104rl\telse levelVar = MonsterLevelVar.etc\tend\t-- 傷害比其他值更漸進\tlocal damageMult = ((LevelRatio[monsterLevel] - 1.0) * 0.5) + 1.0\tmonster.damage = math.floor(Game.RandomInt(levelVar.damageMin, levelVar.damageMax) * damageMult)\tmonster.health = math.floor(Game.RandomInt(levelVar.hpMin, levelVar.hpMax) * LevelRatio[monsterLevel])\tmonster.coin = math.floor(Game.RandomInt(levelVar.coinMin, levelVar.coinMax) * LevelRatio[monsterLevel])\tmonster.user.exp = math.floor(monster.health * MonsterExpMult) -- 玩家捕捉該怪物時將獲得的經驗值\t-- 根據確定的等級設定顏色和能力\tif grade == MonsterGrade.rare then monster:SetRenderFX(Game.RENDERFX.GLOWSHELL) monster:SetRenderColor(&#123;r = 0, g = 30, b = 255&#125;) monster.health = math.floor(monster.health * 3.0) monster.damage = monster.damage * 1.5 monster.speed = 1.5 monster.user.exp = math.floor(monster.user.exp * 1.5)\telseif grade == MonsterGrade.unique then monster:SetRenderFX(Game.RENDERFX.GLOWSHELL) monster:SetRenderColor(&#123;r = 255, g = 30, b = 30&#125;) monster.health = math.floor(monster.health * 5.0) monster.damage = monster.damage * 2.0 monster.speed = 1.5 monster.user.exp = math.floor(monster.user.exp * 3.0)\telseif grade == MonsterGrade.legend then monster:SetRenderFX(Game.RENDERFX.GLOWSHELL) monster:SetRenderColor(&#123;r = 255, g = 255, b = 100&#125;) monster.health = math.floor(monster.health * 12.0) monster.damage = monster.damage * 2.0 monster.speed = 2.5 monster.user.exp = math.floor(monster.user.exp * 10.0)\tendend-- 在指定地點創造一群怪物function CreateMonsters(type, num, pos, groupid, grade)\tif grade == nil then grade = MonsterGrade.normal\tend\tresult = &#123;&#125;\t-- 創造num數量的怪物\tfor i = 1, num do monster = Game.Monster.Create(type, pos) if monster then -- 依怪物等級設定能力 SetMonsterAttribute(monster, grade) -- 儲存怪物所屬的組號，並將此組號加一 monster.user.groupid = groupid if monsterGroupCnt[groupid] then monsterGroupCnt[groupid] = monsterGroupCnt[groupid] + 1 else monsterGroupCnt[groupid] = 1; end -- 保存結果 table.insert(result, monster) end\tend\treturn resultend-- 當所有怪物都死掉時所呼叫的函數function OnMonsterKilled(monster) if monster.user.waveFunc then if monsterWaveFuncState == WaveFuncState.enable then monster.user.waveFunc(true, monster.user.waveFuncArg) else monster.user.waveFunc = nil end end -- boss團死了 if monster.user.groupid == 8055 then monsterWaveFuncState = WaveFuncState.disable difficultySelectPlayer = 0 Game.KillAllMonsters() -- 下次更新後殺死所有怪物 end Game.SetTrigger(&#x27;OnMonsterKilled&#x27; .. monster.user.groupid, true)end--[[ 武器相關自訂函數 ]]-- 設定所有武器的最低基礎統計數據function SetWeaponAttributeDefault(weapon)\tif weapon == nil then return\tend\t-- 副武器有無限彈匣\tif weapon:GetWeaponType() == Game.WEAPONTYPE.PISTOL then weapon.infiniteclip = true\telse weapon:AddClip1(3) -- 提供3個標準彈匣\tend\t-- 基本水平\tif weapon.user.level == nil then weapon.user.level = Common.GetWeaponOption(weapon.weaponid).user.level\tend\t-- 基本水平\tweapon.user.grade = WeaponGrade.normal\tweapon.color = Game.WEAPONCOLOR.WHITEend-- 依等級設定武器能力function SetWeaponAttribute(weapon, level)\tif weapon == nil then return\tend\t-- 基本能力設定\tSetWeaponAttributeDefault(weapon)\t-- 等級設定\tweapon.user.level = level\t-- 取得目前武器的WeaponOption和等級。\tlocal option = Common.GetWeaponOption(weapon.weaponid)\tlocal grade = option.user.grade\t-- 按等級決定出現機率\tlocal weightMax = 0.0\tfor i = grade, WeaponGrade.END do weightMax = weightMax + WeaponGradeProb[i]\tend\tlocal weight = Game.RandomFloat(0.0, weightMax)\tlocal weightSum = 0.0\tfor i = grade, WeaponGrade.END do weightSum = weightSum + WeaponGradeProb[i] if weight &lt;= weightSum then grade = i break end\tend\t-- 按等級、等級和隨機進行傷害計算\tweapon.damage = WeaponLevelDamage * LevelRatio[level]\tweapon.damage = weapon.damage * (WeaponGradeDamage[grade] + Game.RandomFloat(-WeaponRandomDamage, WeaponRandomDamage))\t-- 隨機能力的最大數量\tlocal maxAttrNum = 0\t-- 根據確定的等級設定能力的顏色和數量\tif grade == WeaponGrade.normal then weapon.color = Game.WEAPONCOLOR.WHITE maxAttrNum = 0\telseif grade == WeaponGrade.rare then weapon.color = Game.WEAPONCOLOR.BLUE maxAttrNum = 1\telseif grade == WeaponGrade.unique then weapon.color = Game.WEAPONCOLOR.RED maxAttrNum = 2\telseif grade == WeaponGrade.legend then weapon.color = Game.WEAPONCOLOR.ORANGE maxAttrNum = 3\tend\t-- 防止重複出現的能力\tlocal attrDuplicateCheck = &#123;&#125;\tif weapon:GetWeaponType() == Game.WEAPONTYPE.PISTOL then attrDuplicateCheck[5] = true\tend\t-- 能力分數判定\tlocal attrNum = Game.RandomInt(0, maxAttrNum)\tfor i = 1, attrNum do local attrType = Game.RandomInt(1, 5) -- 從speed到infiniteclip的 5 種類型 if attrDuplicateCheck[attrType] then -- 如果能力重疊的話 i = i - 1 else attrDuplicateCheck[attrType] = true if attrType == 1 then weapon.speed = Game.RandomFloat(1.2, 1.3) elseif attrType == 2 then weapon.knockback = Game.RandomFloat(1.2, 2.0) weapon.flinch = Game.RandomFloat(1.2, 2.0) elseif attrType == 3 then weapon.criticalrate = Game.RandomFloat(0.03, 0.2) weapon.criticaldamage = Game.RandomFloat(1.5, 2.5) elseif attrType == 4 then weapon.bloodsucking = Game.RandomFloat(0.01, 0.03) elseif attrType == 5 then weapon.infiniteclip = true end end\tendend-- 隨機化武器等級（使用怪物等級）function GetWeaponRandomLevel(level)\tlocal minLevel = level - 5\tlocal maxLevel = level + 3\tif minLevel &lt; LEVEL_MIN then minLevel = LEVEL_MIN\tend\tif maxLevel &gt; WEAPONLEVEL_MAX then maxLevel = WEAPONLEVEL_MAX\tend\treturn Game.RandomInt(minLevel, maxLevel)end-- 隨機武器生成（使用等級、位置）function CreateWeapon(level, pos)\t-- 隨機決定武器類型（使用武器等級）\tlocal weightMax = 0.0\tlocal list = &#123;&#125;\tfor i = 1, #WeaponList do local weaponOption = Common.GetWeaponOption(WeaponList[i]) if weaponOption.user.level &lt;= level then table.insert(list, weaponOption) weightMax = weightMax + (LevelRatio[weaponOption.user.level] * WeaponGradeProb[weaponOption.user.grade]) end\tend\tlocal type = 0\tlocal weightSum = 0.0\tlocal weight = Game.RandomFloat(0.0, weightMax)\tfor i = 1, #list do weightSum = weightSum + (LevelRatio[list[i].user.level] * WeaponGradeProb[list[i].user.grade]) if weight &lt;= weightSum then type = list[i].weaponid break end\tend\tif type == 0 then return nil\tend\tlocal weapon = Game.Weapon.CreateAndDrop(type, pos)\tif weapon then SetWeaponAttribute(weapon, level)\tend\treturn weaponend--[[ 與玩家等級相關的自訂功能 ]]-- 當玩家升級時function OnLevelUp(player)\t-- 增加耐力\tplayer.maxhealth = math.floor(100 * LevelRatio[player.user.level])\tplayer.health = player.maxhealth\t-- 在普通難度下，怪物等級會根據玩家等級而變化\tif mapDifficulty == SignalToGame.difficulty0 then if player.user.level &gt; monsterLevel then monsterLevel = player.user.level if monsterLevel &gt; 30 then monsterLevel = 30 end end\tend\t-- 比較 WeaponOption 和等級並顯示 UI 鎖定顯示（商店櫥窗）\tfor i = 1, #BuymenuWeaponList do local option = Common.GetWeaponOption(BuymenuWeaponList[i]) if option then player:SetBuymenuLockedUI(BuymenuWeaponList[i], option.user.level &gt; player.user.level, option.user.level) end\tend\t-- 比較武器和等級並顯示 UI 鎖定顯示（武器庫存視窗）\tlocal invenWeapons = player:GetWeaponInvenList()\tfor i = 1, #invenWeapons do player:SetWeaponInvenLockedUI(invenWeapons[i], invenWeapons[i].user.level &gt; player.user.level, invenWeapons[i].user.level)\tendend-- 根據玩家目前等級和經驗值計算經驗百分比function CalcExpRate(level, exp)\treturn exp / PlayerRequireExp[level]end-- 給予玩家經驗值function AddExp(player, exp)\tlocal pu = player.user\t-- 如果您已達到滿級，請跳過\tif pu.level &gt;= LEVEL_MAX then return\tend\tpu.exp = pu.exp + exp -- 升級\tif pu.exp &gt; PlayerRequireExp[pu.level] then pu.level = pu.level + 1 if pu.level &gt;= LEVEL_MAX then pu.exp = 0 else pu.exp = pu.exp - PlayerRequireExp[pu.level - 1] end OnLevelUp(player)\tend\t-- 顯示和更新等級/經驗 UI\tpu.expRate = CalcExpRate(pu.level, pu.exp)\tplayer:SetLevelUI(pu.level, pu.expRate)end--[[ 工作室呼叫功能（武器、怪物相關） ]]-- 字串分割函數function splitstr_tonumber(inputstr)\tlocal t = &#123;&#125;\tfor str in string.gmatch(inputstr, &quot;([^,]*)&quot;) do table.insert(t, tonumber(str))\tend\treturn tend-- 指定每個怪物組的 AttackTo 位置MonsterAttackPos = &#123;\t-- CreateDefaultMonsters\t[1] = &#123;x = -12, y = 100, z = 1&#125;,\t[2] = &#123;x = -9, y = 98, z = 1&#125;,\t[3] = &#123;x = 14, y = 77, z = 1&#125;,\t[7] = &#123;x = 80, y = 26, z = 1&#125;,\t[9] = &#123;x = 81, y = 22, z = 1&#125;,\t[11] = &#123;x = 81, y = 24, z = 1&#125;,\t[13] = &#123;x = 36, y = -14, z = 1&#125;,\t[14] = &#123;x = 35, y = -11, z = 1&#125;,\t[17] = &#123;x = 34, y = -32, z = -3&#125;,\t[18] = &#123;x = 35, y = -40, z = -3&#125;,\t[8055] = &#123;x = 25, y = -31, z = -3&#125;,\t-- CreateWaveMonsters\t[1000] = &#123;x = -4, y = 72, z = 1&#125;,\t-- CreateSpecialMonsters\t[10000] = &#123;x = -12, y = 108, z = 1&#125;,&#125;-- 怪物等級的確定function GetRandomGrade(min, max)\tif min == max then return min\tend\tlocal grade = min\tlocal weightMax = 0.0\tfor i = min, max do weightMax = weightMax + MonsterGradeProb[i]\tend\tlocal weight = Game.RandomFloat(0.0, weightMax)\tlocal weightSum = 0.0\tfor i = min, max do weightSum = weightSum + MonsterGradeProb[i] if weight &lt;= weightSum then return i end\tend\treturn minendfunction CreateDefaultMonsters(callerOn, arg)\tif callerOn == nil or callerOn == false then return\tend\tlocal args = splitstr_tonumber(arg) -- 拆分 arg 字串並將其儲存在數字數組中。\tlocal type = MonsterTypes[args[1]] -- 怪物類型\tlocal num = args[2] -- 召喚怪物數量\tlocal groupid = args[3] -- 怪物群組ID\tlocal grade = GetRandomGrade(args[4], args[5]) -- 怪物等級\t-- Game.GetScriptCaller()：取得呼叫函數的腳本函數呼叫VoxelEntity。\tlocal monsters = CreateMonsters(type, num, Game.GetScriptCaller().position, groupid, grade)\t-- AttackTo 需要指定地點的怪物群\tfor i = 1, #monsters do if MonsterAttackPos[groupid] then monsters[i]:AttackTo(MonsterAttackPos[groupid]) -- 移動到指定座標時進行攻擊 end\tendend-- 怪物wave成功能function CreateWaveMonsters(callerOn, arg)\tif callerOn == nil or callerOn == false then return\tend\tlocal args = splitstr_tonumber(arg)\tlocal type = MonsterTypes[args[1]]\tlocal num = args[2]\tlocal groupid = args[3]\tlocal grade = GetRandomGrade(args[4], args[5])\tlocal waveCnt = args[6] -- 產生的wave數\tif monsterWaveCnt[groupid] then monsterWaveCnt[groupid] = monsterWaveCnt[groupid] + 1 if monsterWaveCnt[groupid] &gt; waveCnt then if monsterWaveCnt[groupid] == waveCnt + 1 then Game.SetTrigger(&#x27;OnWaveEnded&#x27; .. groupid, true) end return end\telse monsterWaveCnt[groupid] = 1\tend\tif Game.GetScriptCaller() then monsterWavePosition[groupid] = Game.GetScriptCaller().position\tend\tlocal monsters = CreateMonsters(type, num, monsterWavePosition[groupid], groupid, grade)\tfor i = 1, #monsters do monsters[i].user.waveFunc = CreateWaveMonsters monsters[i].user.waveFuncArg = arg if MonsterAttackPos[groupid] then monsters[i]:AttackTo(MonsterAttackPos[groupid]) -- 移動到指定座標時進行攻擊 end\tendend-- 特定物品掉落怪物創建功能function CreateSpecialMonsters(callerOn, arg)\tif callerOn then local args = splitstr_tonumber(arg) local type = MonsterTypes[args[1]] local num = args[2] local groupid = args[3] local grade = GetRandomGrade(args[4], args[5]) local monsters = CreateMonsters(type, num, Game.GetScriptCaller().position, groupid, grade) for i = 1, #monsters do monsters[i].user.specialWeaponDrop = groupid -- 指定特定物品掉落 if MonsterAttackPos[groupid] then monsters[i]:AttackTo(MonsterAttackPos[groupid]) -- 移動到指定座標時進行攻擊 end end\tendend-- 特定物品掉落指定功能function CreateSpecialWeapon(specialWeaponDrop, position)\tif specialWeaponDrop == 10000 then local weapon = Game.Weapon.CreateAndDrop(Common.WEAPON.P90, position) SetWeaponAttributeDefault(weapon)\telseif specialWeaponDrop == 10001 then local weapon = Game.Weapon.CreateAndDrop(Common.WEAPON.M134Minigun, position) SetWeaponAttributeDefault(weapon)\tendend-- 創建放置在地圖上的基本武器function CreateDefaultWeapon() local weapon = Game.Weapon.CreateAndDrop(Common.WEAPON.USP45, &#123;x = -6, y = 150, z = 1&#125;)\tSetWeaponAttributeDefault(weapon)end-- 隨機武器生成function CreateRandomWeapon(callerOn, arg)\tif callerOn then CreateWeapon(tonumber(arg), Game.GetScriptCaller().position)\tendend--[[ 事件函數 ]]-- 當玩家在選擇職業後首次生成時調用的函數function Game.Rule:OnPlayerJoiningSpawn(player)\t-- 儲存到玩家數組\tplayers[player.index] = player\t-- 將相機改為第三人稱，將輸入法改為基於滑鼠指標\tplayer:SetThirdPersonFixedView(-45, 53, 100, 250) -- yaw, pitch, minDist, maxDist\t-- ThirdPersonFixedView 修改滑鼠指標光線投射位置的計算方式\tplayer:SetThirdPersonFixedPlane(Game.THIRDPERSON_FIXED_PLANE.GROUND)\t-- 基礎水準、經驗\tplayer.user.level = 1\tplayer.user.exp = 0\tplayer.user.expRate = 0\t-- UI按級別初始化\tOnLevelUp(player) -- 武器鎖UI初始化目的\tplayer:SetLevelUI(player.user.level, player.user.expRate) -- 等級/經驗 UI 設定\t-- 團隊設定\tplayer.team = Game.TEAM.CTend-- entity 當（怪物、玩家等）受到傷害時呼叫的函數。function Game.Rule:OnTakeDamage(victim, attacker, damage, weapontype, hitbox)\tif attacker == nil or victim == nil then return end\tif victim:IsMonster() then victim = victim:ToMonster() victim:ShowOverheadDamage(damage, 0) -- 傷害顯示在頭頂上方。 如果第二個參數（玩家索引）為 0，則會顯示給所有人。\tendend-- entity死亡時呼叫的函數function Game.Rule:OnKilled(victim, killer)\tif victim == nil or killer == nil then return\tend\t-- 當玩家死亡時使他復活\tif victim:IsPlayer() then victim = victim:ToPlayer() -- 如果難度不正常，經驗值減少10%。 if mapDifficulty ~= SignalToGame.difficulty0 then AddExp(victim, -math.floor(PlayerRequireExp[victim.user.level] / 10.0)) end if victim.user.spawnable == true then victim:Respawn() end -- 隱藏重新載入 UI victim:Signal(SignalToUI.reloadFinished)\tend\t-- 當怪物死亡時\tif victim:IsMonster() then victim = victim:ToMonster() -- 如果killer是玩家，則會給予經驗值。 if killer:IsPlayer() then killer = killer:ToPlayer() AddExp(killer, victim.user.exp) end -- 為怪物製作指定武器或根據怪物等級檢查武器掉落機率來掉落武器。 if victim.user.specialWeaponDrop then CreateSpecialWeapon(victim.user.specialWeaponDrop, victim.position) else weight = Game.RandomFloat(0.0, 1.0) if weight &lt;= WeaponDropProb[victim.user.grade] then CreateWeapon(GetWeaponRandomLevel(victim.user.level), victim.position) end end -- 檢查怪物數量，如果達到 0，則在 OnMonsterKilled 函數中傳送到工作室。 monsterGroupCnt[victim.user.groupid] = monsterGroupCnt[victim.user.groupid] - 1 if monsterGroupCnt[victim.user.groupid] &lt;= 0 then monsterGroupCnt[victim.user.groupid] = nil OnMonsterKilled(victim) end\tendend-- 偵測武器是否可以購買的功能-- 未包含在腳本武器清單中的武器不會被呼叫。function Game.Rule:CanBuyWeapon(player, weaponid)\tlocal weaponOption = Common.GetWeaponOption(weaponid)\treturn weaponOption.user.level &lt;= player.user.levelend-- 偵測武器是否可以手持的功能-- 未包含在腳本武器清單中的武器不會被呼叫。-- 如果從未使用過 Weapon 類，則 Weapon 參數將作為 nil 傳遞。function Game.Rule:CanHaveWeaponInHand(player, weaponid, weapon)\tlocal weaponOptionCheck = Common.GetWeaponOption(weaponid).user.level &lt;= player.user.level\tlocal weaponCheck = weapon == nil or weapon.user.level == nil or weapon.user.level &lt;= player.user.level\treturn weaponOptionCheck and weaponCheckend-- 取得武器時呼叫的函數-- 未包含在腳本武器清單中的武器不會被呼叫。-- 如果從未使用過 Weapon 類，則 Weapon 參數將作為 nil 傳遞。function Game.Rule:OnGetWeapon(player, weaponid, weapon)\tif weapon == nil then return\tend\t-- 基本能力設定\tif weapon.user.level == nil then SetWeaponAttributeDefault(weapon)\tend\t-- 鎖定的使用者介面更新\tplayer:SetWeaponInvenLockedUI(weapon, weapon.user.level &gt; player.user.level, weapon.user.level)end-- 用於傳送重裝時間的變數reloadTimeSync = Game.SyncValue.Create(&quot;reloadTime&quot;)-- 重新載入時呼叫的函數-- 如果 Weapon 類別從未使用過或不是腳本武器，則 Weapon 參數將作為 nil 傳遞。function Game.Rule:OnReload(player, weapon, time)\t-- 顯示重新載入 UI\tplayer:Signal(SignalToUI.reloadStarted)\t-- 交付重裝時間\treloadTimeSync.value = timeend-- 載入後呼叫的函數-- 如果 Weapon 類別從未使用過或不是腳本武器，則 Weapon 參數將作為 nil 傳遞。function Game.Rule:OnReloadFinished(player, weapon)\tplayer:Signal(SignalToUI.reloadFinished) -- 隱藏重新載入 UIend-- 當玩家切換武器時呼叫的函數function Game.Rule:OnSwitchWeapon(player)\tplayer:Signal(SignalToUI.reloadFinished) -- 隱藏重新載入 UIend-- 啟動後呼叫的函數-- 如果 Weapon 類別從未使用過或不是腳本武器，則 Weapon 參數將作為 nil 傳遞。function Game.Rule:PostFireWeapon(player, weapon, time)\t-- 僅當武器的射擊間隔超過 1 秒時才會顯示裝彈 UI。\tif time &gt; 1.0 then -- 顯示重新載入 UI player:Signal(SignalToUI.reloadStarted) -- 交付重裝時間 reloadTimeSync.value = time\tendend-- 當玩家拔出武器時呼叫的函數function Game.Rule:OnDeployWeapon(player, weapon)\tplayer:Signal(SignalToUI.reloadFinished) -- 隱藏重新載入 UIend-- 保存每個玩家的保存訊息function Game.Rule:OnGameSave(player)\tif player == nil then return\tend\t-- 保存等級和經驗值\tplayer:SetGameSave(&#x27;level&#x27;, player.user.level)\tplayer:SetGameSave(&#x27;exp&#x27;, player.user.exp)\t-- 保存您目前持有的武器的等級\tlocal primaryWeapon = player:GetPrimaryWeapon()\tlocal secondaryWeapon = player:GetSecondaryWeapon()\tif primaryWeapon then player:SetGameSave(&#x27;wpn_lv_pri&#x27;, primaryWeapon.user.level)\telse player:SetGameSave(&#x27;wpn_lv_pri&#x27;, 0)\tend\tif secondaryWeapon then player:SetGameSave(&#x27;wpn_lv_sec&#x27;, secondaryWeapon.user.level)\telse player:SetGameSave(&#x27;wpn_lv_sec&#x27;, 0)\tend\t-- 保存庫存武器等級\tlocal invenWeapons = player:GetWeaponInvenList()\tfor i = 1, #invenWeapons do player:SetGameSave(&#x27;wpn_lv_inven&#x27; .. i, invenWeapons[i].user.level)\tendendfunction DoubleToInt(number)\treturn math.floor(math.abs(number + EPSILON))end-- 載入每個玩家的保存訊息function Game.Rule:OnLoadGameSave(player)\tif player == nil then return\tend\t-- 等級、經驗負荷\tplayer.user.level = DoubleToInt(player:GetGameSave(&#x27;level&#x27;))\tplayer.user.exp = DoubleToInt(player:GetGameSave(&#x27;exp&#x27;))\tif player.user.level == nil then player.user.level = 1\tend\tif player.user.exp == nil then player.user.exp = 0\tend\tplayer.user.expRate = CalcExpRate(player.user.level, player.user.exp)\t-- 載入你目前持有的武器\tlocal primaryWeapon = player:GetPrimaryWeapon()\tlocal secondaryWeapon = player:GetSecondaryWeapon()\tif primaryWeapon then primaryWeapon.user.level = DoubleToInt(player:GetGameSave(&#x27;wpn_lv_pri&#x27;))\tend\tif secondaryWeapon then secondaryWeapon.user.level = DoubleToInt(player:GetGameSave(&#x27;wpn_lv_sec&#x27;))\tend\t-- 載入庫存武器等級\tlocal invenWeapons = player:GetWeaponInvenList()\tfor i = 1, #invenWeapons do invenWeapons[i].user.level = DoubleToInt(player:GetGameSave(&#x27;wpn_lv_inven&#x27; .. i))\tend\t-- UI按級別初始化\tOnLevelUp(player) -- 武器鎖UI初始化目的\tplayer:SetLevelUI(player.user.level, player.user.expRate) -- 等級/經驗 UI 設定end-- 重置每個玩家的保存訊息function Game.Rule:OnClearGameSave(player)\tplayer.user.level = 1\tplayer.user.exp = 0\tplayer.user.expRate = 0\tplayer:RemoveWeapon()\tplayer:ClearWeaponInven()\t-- UI按級別初始化\tOnLevelUp(player) -- 武器鎖UI初始化目的\tplayer:SetLevelUI(player.user.level, player.user.expRate) -- 等級/經驗 UI 設定end--[[ 透過UI傳輸訊息 ]]function Game.Rule:OnPlayerSignal(player, signal)\tif signal == SignalToGame.openWeaponInven then player:ToggleWeaponInven()\tendend-- 打開商店（呼叫Studio的函數）function ShowBuymenu(callerOn)\tlocal triggerEnt = Game.GetTriggerEntity()\tif triggerEnt and triggerEnt:IsPlayer() then triggerEnt = triggerEnt:ToPlayer() triggerEnt:ShowBuymenu()\tendend"}]